<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · LearnAPI.jl</title><meta name="title" content="Reference · LearnAPI.jl"/><meta property="og:title" content="Reference · LearnAPI.jl"/><meta property="twitter:title" content="Reference · LearnAPI.jl"/><meta name="description" content="Documentation for LearnAPI.jl."/><meta property="og:description" content="Documentation for LearnAPI.jl."/><meta property="twitter:description" content="Documentation for LearnAPI.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LearnAPI.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../anatomy_of_an_implementation/">Anatomy of an Implementation</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#scope"><span>Important terms and concepts</span></a></li><li><a class="tocitem" href="#Methods"><span>Methods</span></a></li></ul></li><li><a class="tocitem" href="../kinds_of_target_proxy/">Kinds of Target Proxy</a></li><li><a class="tocitem" href="../fit/">fit</a></li><li><a class="tocitem" href="../predict_transform/">predict, transform, and relatives</a></li><li><a class="tocitem" href="../minimize/">minimize</a></li><li><a class="tocitem" href="../obs/">obs</a></li><li><a class="tocitem" href="../accessor_functions/">Accessor Functions</a></li><li><a class="tocitem" href="../traits/">Algorithm Traits</a></li><li><a class="tocitem" href="../common_implementation_patterns/">Common Implementation Patterns</a></li><li><a class="tocitem" href="../testing_an_implementation/">Testing an Implementation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaAI/LearnAPI.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaAI/LearnAPI.jl/blob/dev/docs/src/reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="reference"><a class="docs-heading-anchor" href="#reference">Reference</a><a id="reference-1"></a><a class="docs-heading-anchor-permalink" href="#reference" title="Permalink"></a></h1><p>Here we give the definitive specification of the LearnAPI.jl interface. For informal guides see <a href="../anatomy_of_an_implementation/#Anatomy-of-an-Implementation">Anatomy of an Implementation</a> and <a href="../common_implementation_patterns/#Common-Implementation-Patterns">Common Implementation Patterns</a>.</p><h2 id="scope"><a class="docs-heading-anchor" href="#scope">Important terms and concepts</a><a id="scope-1"></a><a class="docs-heading-anchor-permalink" href="#scope" title="Permalink"></a></h2><p>The LearnAPI.jl specification is predicated on a few basic, informally defined notions:</p><h3 id="Data-and-observations"><a class="docs-heading-anchor" href="#Data-and-observations">Data and observations</a><a id="Data-and-observations-1"></a><a class="docs-heading-anchor-permalink" href="#Data-and-observations" title="Permalink"></a></h3><p>ML/statistical algorithms are typically applied in conjunction with resampling of <em>observations</em>, as in <a href="https://en.wikipedia.org/wiki/Cross-validation_(statistics)">cross-validation</a>. In this document <em>data</em> will always refer to objects encapsulating an ordered sequence of individual observations. If an algorithm is trained using multiple data objects, it is undertood that individual objects share the same number of observations, and that resampling of one component implies synchronized resampling of the others.</p><p>A <code>DataFrame</code> instance, from <a href="https://dataframes.juliadata.org/stable/">DataFrames.jl</a>, is an example of data, the observations being the rows. LearnAPI.jl makes no assumptions about how observations can be accessed, except in the case of the output of <a href="../obs/#data_interface"><code>obs</code></a>, which must implement the MLUtils.jl <code>getobs</code>/<code>numobs</code> interface. For example, it is generally ambiguous whether the rows or columns of a matrix are considered observations, but if a matrix is returned by <a href="../obs/#data_interface"><code>obs</code></a> the observations must be the columns.</p><h3 id="hyperparameters"><a class="docs-heading-anchor" href="#hyperparameters">Hyperparameters</a><a id="hyperparameters-1"></a><a class="docs-heading-anchor-permalink" href="#hyperparameters" title="Permalink"></a></h3><p>Besides the data it consumes, a machine learning algorithm&#39;s behavior is governed by a number of user-specified <em>hyperparameters</em>, such as the number of trees in a random forest. In LearnAPI.jl, one is allowed to have hyperparematers that are not data-generic. For example, a class weight dictionary will only make sense for a target taking values in the set of dictionary keys. </p><h3 id="proxy"><a class="docs-heading-anchor" href="#proxy">Targets and target proxies</a><a id="proxy-1"></a><a class="docs-heading-anchor-permalink" href="#proxy" title="Permalink"></a></h3><h4 id="Context"><a class="docs-heading-anchor" href="#Context">Context</a><a id="Context-1"></a><a class="docs-heading-anchor-permalink" href="#Context" title="Permalink"></a></h4><p>After training, a supervised classifier predicts labels on some input which are then compared with ground truth labels using some accuracy measure, to assesses the performance of the classifier. Alternatively, the classifier predicts class probabilities, which are instead paired with ground truth labels using a proper scoring rule, say. In outlier detection, &quot;outlier&quot;/&quot;inlier&quot; predictions, or probability-like scores, are similarly compared with ground truth labels. In clustering, integer labels assigned to observations by the clustering algorithm can can be paired with human labels using, say, the Rand index. In survival analysis, predicted survival functions or probability distributions are compared with censored ground truth survival times.</p><h4 id="Definitions"><a class="docs-heading-anchor" href="#Definitions">Definitions</a><a id="Definitions-1"></a><a class="docs-heading-anchor-permalink" href="#Definitions" title="Permalink"></a></h4><p>More generally, whenever we have a variable (e.g., a class label) that can (in principle) can be paired with a predicted value, or some predicted &quot;proxy&quot; for that variable (such as a class probability), then we call the variable a <em>target</em> variable, and the predicted output a <em>target proxy</em>. In this definition, it is immaterial whether or not the target appears in training (is supervised) or whether or not the model generalizes to new observations (&quot;learns&quot;).</p><p>LearnAPI.jl provides singleton <a href="../kinds_of_target_proxy/#proxy_types">target proxy types</a> for prediction dispatch in LearnAPI.jl. These are also used to distinguish performance metrics provided by the package <a href="https://juliaai.github.io/StatisticalMeasures.jl/dev/">StatisticalMeasures.jl</a>.</p><h3 id="algorithms"><a class="docs-heading-anchor" href="#algorithms">Algorithms</a><a id="algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#algorithms" title="Permalink"></a></h3><p>An object implementing the LearnAPI.jl interface is called an <em>algorithm</em>, although it is more accurately &quot;the configuration of some algorithm&quot;.¹ It will have a type name reflecting the name of some ML/statistics algorithm (e.g., <code>RandomForestRegressor</code>) and it will encapsulate a particular set of user-specified <a href="#hyperparameters">hyperparameters</a>.</p><p>Additionally, for <code>alg::Alg</code> to be a LearnAPI algorithm, we require:</p><ul><li><p><code>Base.propertynames(alg)</code> returns the hyperparameters of <code>alg</code>.</p></li><li><p>If <code>alg</code> is an algorithm, then so are all instances of the same type.</p></li><li><p>If <code>_alg</code> is another algorithm, then <code>alg == _alg</code> if and only if <code>typeof(alg) == typeof(_alg)</code> and corresponding properties are <code>==</code>. This includes properties that are random number generators (which should be copied in training to avoid mutation).</p></li><li><p>If an algorithm has other algorithms as hyperparameters, then <a href="../traits/#LearnAPI.is_composite"><code>LearnAPI.is_composite</code></a><code>(alg)</code> must be <code>true</code> (fallback is <code>false</code>).</p></li><li><p>A keyword constructor for <code>Alg</code> exists, providing default values for <em>all</em> non-algorithm hyperparameters.</p></li><li><p>At least one non-trait LearnAPI.jl function must be overloaded for instances of <code>Alg</code>, and accordingly <code>LearnAPI.functions(algorithm)</code> must be non-empty.</p></li></ul><p>Any object <code>alg</code> for which <a href="../traits/#LearnAPI.functions"><code>LearnAPI.functions</code></a><code>(alg)</code> is non-empty is understood have a valid implementation of the LearnAPI.jl interface.</p><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><p>Any instance of <code>GradientRidgeRegressor</code> defined below meets all but the last criterion above:</p><pre><code class="language-julia hljs">struct GradientRidgeRegressor{T&lt;:Real}
	learning_rate::T
	epochs::Int
	l2_regularization::T
end
GradientRidgeRegressor(; learning_rate=0.01, epochs=10, l2_regularization=0.01) =
    GradientRidgeRegressor(learning_rate, epochs, l2_regularization)</code></pre><p>The same is not true if we make this a <code>mutable struct</code>. In that case we will need to appropriately overload <code>Base.==</code> for <code>GradientRidgeRegressor</code>.</p><h2 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h2><p>Only these method names are exported: <code>fit</code>, <code>obsfit</code>, <code>predict</code>, <code>obspredict</code>, <code>transform</code>, <code>obstransform</code>, <code>inverse_transform</code>, <code>minimize</code>, and <code>obs</code>. All new implementations must implement <a href="../fit/#LearnAPI.obsfit"><code>obsfit</code></a>, the accessor function <a href="../minimize/#algorithm_minimize"><code>LearnAPI.algorithm</code></a> and the trait <a href="../traits/#LearnAPI.functions"><code>LearnAPI.functions</code></a>.</p><ul><li><p><a href="../fit/#LearnAPI.fit"><code>fit</code></a>/<a href="../fit/#LearnAPI.obsfit"><code>obsfit</code></a>: for training algorithms that generalize to new data</p></li><li><p><a href="../predict_transform/#operations"><code>predict</code></a>/<a href="../predict_transform/#LearnAPI.obspredict"><code>obspredict</code></a>: for outputting <a href="#proxy">targets</a> or <a href="#proxy">target proxies</a> (such as probability density functions)</p></li><li><p><a href="../predict_transform/#operations"><code>transform</code></a>/<a href="../predict_transform/#LearnAPI.obstransform"><code>obstransform</code></a>: similar to <code>predict</code>, but for arbitrary kinds of output, and which can be paired with an <code>inverse_transform</code> method</p></li><li><p><a href="../predict_transform/#operations"><code>inverse_transform</code></a>: for inverting the output of <code>transform</code> (&quot;inverting&quot; broadly understood)</p></li><li><p><a href="../minimize/#algorithm_minimize"><code>minimize</code></a>: for stripping the <code>model</code> output by <code>fit</code> of inessential content, for purposes of serialization.</p></li><li><p><a href="../obs/#data_interface"><code>obs</code></a>: a method for exposing to the user &quot;optimized&quot;, algorithm-specific representations of data, which can be passed to <code>obsfit</code>, <code>obspredict</code> or <code>obstransform</code>, but which can also be efficiently resampled using the <code>getobs</code>/<code>numobs</code> interface provided by <a href="https://github.com/JuliaML/MLUtils.jl">MLUtils.jl</a>.</p></li><li><p><a href="../accessor_functions/#accessor_functions">Accessor functions</a>: include things like <code>feature_importances</code> and <code>training_losses</code>, for extracting, from training outcomes, information common to many algorithms. </p></li><li><p><a href="../traits/#traits">Algorithm traits</a>: special methods that promise specific algorithm behavior or for recording general information about the algorithm. The only universally compulsory trait is <code>LearnAPI.functions(algorithm)</code>, which returns a list of the explicitly overloaded non-trait methods.</p></li></ul><hr/><p>¹ We acknowledge users may not like this terminology, and may know &quot;algorithm&quot; by some other name, such as &quot;strategy&quot;, &quot;options&quot;, &quot;hyperparameter set&quot;, &quot;configuration&quot;, or &quot;model&quot;. Consensus on this point is difficult; see, e.g., <a href="https://discourse.julialang.org/t/ann-learnapi-jl-proposal-for-a-basement-level-machine-learning-api/93048/20">this</a> Julia Discourse discussion.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../anatomy_of_an_implementation/">« Anatomy of an Implementation</a><a class="docs-footer-nextpage" href="../kinds_of_target_proxy/">Kinds of Target Proxy »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Tuesday 28 November 2023 09:00">Tuesday 28 November 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
