<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Algorithm Traits · LearnAPI.jl</title><meta name="title" content="Algorithm Traits · LearnAPI.jl"/><meta property="og:title" content="Algorithm Traits · LearnAPI.jl"/><meta property="twitter:title" content="Algorithm Traits · LearnAPI.jl"/><meta name="description" content="Documentation for LearnAPI.jl."/><meta property="og:description" content="Documentation for LearnAPI.jl."/><meta property="twitter:description" content="Documentation for LearnAPI.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LearnAPI.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../anatomy_of_an_implementation/">Anatomy of an Implementation</a></li><li><a class="tocitem" href="../reference/">Reference</a></li><li><a class="tocitem" href="../kinds_of_target_proxy/">Kinds of Target Proxy</a></li><li><a class="tocitem" href="../fit/">fit</a></li><li><a class="tocitem" href="../predict_transform/">predict, transform, and relatives</a></li><li><a class="tocitem" href="../minimize/">minimize</a></li><li><a class="tocitem" href="../obs/">obs</a></li><li><a class="tocitem" href="../accessor_functions/">Accessor Functions</a></li><li class="is-active"><a class="tocitem" href>Algorithm Traits</a><ul class="internal"><li><a class="tocitem" href="#trait_summary"><span>Trait summary</span></a></li><li><a class="tocitem" href="#Implementation-guide"><span>Implementation guide</span></a></li><li><a class="tocitem" href="#Reference"><span>Reference</span></a></li></ul></li><li><a class="tocitem" href="../common_implementation_patterns/">Common Implementation Patterns</a></li><li><a class="tocitem" href="../testing_an_implementation/">Testing an Implementation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Algorithm Traits</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Algorithm Traits</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaAI/LearnAPI.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaAI/LearnAPI.jl/blob/dev/docs/src/traits.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="traits"><a class="docs-heading-anchor" href="#traits">Algorithm Traits</a><a id="traits-1"></a><a class="docs-heading-anchor-permalink" href="#traits" title="Permalink"></a></h1><p>Traits generally promise specific algorithm behavior, such as: <em>This algorithm supports per-observation weights, which must appear as the third argument of <code>fit</code></em>, or <em>This algorithm&#39;s <code>transform</code> method predicts <code>Real</code> vectors</em>. They also record more mundane information, such as a package license.</p><p>Algorithm traits are functions whose  (and usually only) argument is an algorithm.</p><h3 id="Special-two-argument-traits"><a class="docs-heading-anchor" href="#Special-two-argument-traits">Special two-argument traits</a><a id="Special-two-argument-traits-1"></a><a class="docs-heading-anchor-permalink" href="#Special-two-argument-traits" title="Permalink"></a></h3><p>The two-argument version of <a href="#LearnAPI.predict_output_scitype"><code>LearnAPI.predict_output_scitype</code></a> and <a href="#LearnAPI.predict_output_scitype"><code>LearnAPI.predict_output_scitype</code></a> are the only overloadable traits with more than one argument.</p><h2 id="trait_summary"><a class="docs-heading-anchor" href="#trait_summary">Trait summary</a><a id="trait_summary-1"></a><a class="docs-heading-anchor-permalink" href="#trait_summary" title="Permalink"></a></h2><h3 id="traits_list"><a class="docs-heading-anchor" href="#traits_list">Overloadable traits</a><a id="traits_list-1"></a><a class="docs-heading-anchor-permalink" href="#traits_list" title="Permalink"></a></h3><p>In the examples column of the table below, <code>Table</code>, <code>Continuous</code>, <code>Sampleable</code> are names owned by the package <a href="https://github.com/JuliaAI/ScientificTypesBase.jl/">ScientificTypesBase.jl</a>.</p><table><tr><th style="text-align: left">trait</th><th style="text-align: left">return value</th><th style="text-align: left">fallback value</th><th style="text-align: left">example</th></tr><tr><td style="text-align: left"><a href="#LearnAPI.functions"><code>LearnAPI.functions</code></a><code>(algorithm)</code></td><td style="text-align: left">functions you can apply to <code>algorithm</code> or associated model (traits excluded)</td><td style="text-align: left"><code>()</code></td><td style="text-align: left"><code>(LearnAPI.fit, LearnAPI.predict, LearnAPI.algorithm)</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.kinds_of_proxy"><code>LearnAPI.kinds_of_proxy</code></a><code>(algorithm)</code></td><td style="text-align: left">instances <code>kop</code> of <code>KindOfProxy</code> for which an implementation of <code>LearnAPI.predict(algorithm, kop, ...)</code> is guaranteed.</td><td style="text-align: left"><code>()</code></td><td style="text-align: left"><code>(Distribution(), Interval())</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.position_of_target"><code>LearnAPI.position_of_target</code></a><code>(algorithm)</code></td><td style="text-align: left">the positional index¹  of the <strong>target</strong> in <code>data</code> in <code>fit(algorithm, data...)</code> calls</td><td style="text-align: left"><code>0</code></td><td style="text-align: left">2</td></tr><tr><td style="text-align: left"><a href="#LearnAPI.position_of_weights"><code>LearnAPI.position_of_weights</code></a><code>(algorithm)</code></td><td style="text-align: left">the positional index¹ of <strong>per-observation weights</strong> in <code>data</code> in <code>fit(algorithm, data...)</code></td><td style="text-align: left"><code>0</code></td><td style="text-align: left">3</td></tr><tr><td style="text-align: left"><a href="#LearnAPI.descriptors"><code>LearnAPI.descriptors</code></a><code>(algorithm)</code></td><td style="text-align: left">lists one or more suggestive algorithm descriptors from <code>LearnAPI.descriptors()</code></td><td style="text-align: left"><code>()</code></td><td style="text-align: left">(:regression, :probabilistic)</td></tr><tr><td style="text-align: left"><a href="#LearnAPI.is_pure_julia"><code>LearnAPI.is_pure_julia</code></a><code>(algorithm)</code></td><td style="text-align: left"><code>true</code> if implementation is 100% Julia code</td><td style="text-align: left"><code>false</code></td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.pkg_name"><code>LearnAPI.pkg_name</code></a><code>(algorithm)</code></td><td style="text-align: left">name of package providing core code (may be different from package providing LearnAPI.jl implementation)</td><td style="text-align: left"><code>&quot;unknown&quot;</code></td><td style="text-align: left"><code>&quot;DecisionTree&quot;</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.pkg_license"><code>LearnAPI.pkg_license</code></a><code>(algorithm)</code></td><td style="text-align: left">name of license of package providing core code</td><td style="text-align: left"><code>&quot;unknown&quot;</code></td><td style="text-align: left"><code>&quot;MIT&quot;</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.doc_url"><code>LearnAPI.doc_url</code></a><code>(algorithm)</code></td><td style="text-align: left">url providing documentation of the core code</td><td style="text-align: left"><code>&quot;unknown&quot;</code></td><td style="text-align: left"><code>&quot;https://en.wikipedia.org/wiki/Decision_tree_learning&quot;</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.load_path"><code>LearnAPI.load_path</code></a><code>(algorithm)</code></td><td style="text-align: left">a string indicating where the struct for <code>typeof(algorithm)</code> is defined, beginning with name of package providing implementation</td><td style="text-align: left"><code>&quot;unknown&quot;</code></td><td style="text-align: left"><code>FastTrees.LearnAPI.DecisionTreeClassifier</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.is_composite"><code>LearnAPI.is_composite</code></a><code>(algorithm)</code></td><td style="text-align: left"><code>true</code> if one or more properties (fields) of <code>algorithm</code> may be an algorithm</td><td style="text-align: left"><code>false</code></td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.human_name"><code>LearnAPI.human_name</code></a><code>(algorithm)</code></td><td style="text-align: left">human name for the algorithm; should be a noun</td><td style="text-align: left">type name with spaces</td><td style="text-align: left">&quot;elastic net regressor&quot;</td></tr><tr><td style="text-align: left"><a href="#LearnAPI.iteration_parameter"><code>LearnAPI.iteration_parameter</code></a><code>(algorithm)</code></td><td style="text-align: left">symbolic name of an iteration parameter</td><td style="text-align: left"><code>nothing</code></td><td style="text-align: left">:epochs</td></tr><tr><td style="text-align: left"><a href="#LearnAPI.fit_scitype"><code>LearnAPI.fit_scitype</code></a><code>(algorithm)</code></td><td style="text-align: left">upper bound on <code>scitype(data)</code> ensuring <code>fit(algorithm, data...)</code> works</td><td style="text-align: left"><code>Union{}</code></td><td style="text-align: left"><code>Tuple{Table(Continuous), AbstractVector{Continuous}}</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.fit_observation_scitype"><code>LearnAPI.fit_observation_scitype</code></a><code>(algorithm)</code></td><td style="text-align: left">upper bound on <code>scitype(observation)</code> for <code>observation</code> in <code>data</code> ensuring <code>fit(algorithm, data...)</code> works</td><td style="text-align: left"><code>Union{}</code></td><td style="text-align: left"><code>Tuple{AbstractVector{Continuous}, Continuous}</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.fit_type"><code>LearnAPI.fit_type</code></a><code>(algorithm)</code></td><td style="text-align: left">upper bound on <code>typeof(data)</code> ensuring <code>fit(algorithm, data...)</code> works</td><td style="text-align: left"><code>Union{}</code></td><td style="text-align: left"><code>Tuple{AbstractMatrix{&lt;:Real}, AbstractVector{&lt;:Real}}</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.fit_observation_type"><code>LearnAPI.fit_observation_type</code></a><code>(algorithm)</code></td><td style="text-align: left">upper bound on <code>typeof(observation)</code> for <code>observation</code> in <code>data</code> ensuring <code>fit(algorithm, data...)</code> works</td><td style="text-align: left"><code>Union{}</code></td><td style="text-align: left"><code>Tuple{AbstractVector{&lt;:Real}, Real}</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.predict_input_scitype"><code>LearnAPI.predict_input_scitype</code></a><code>(algorithm)</code></td><td style="text-align: left">upper bound on <code>scitype(data)</code> ensuring <code>predict(model, kop, data...)</code> works</td><td style="text-align: left"><code>Union{}</code></td><td style="text-align: left"><code>Table(Continuous)</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.predict_input_observation_scitype"><code>LearnAPI.predict_input_observation_scitype</code></a><code>(algorithm)</code></td><td style="text-align: left">upper bound on <code>scitype(observation)</code> for <code>observation</code> in <code>data</code> ensuring <code>predict(model, kop, data...)</code> works</td><td style="text-align: left"><code>Union{}</code></td><td style="text-align: left"><code>Vector{Continuous}</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.predict_input_type"><code>LearnAPI.predict_input_type</code></a><code>(algorithm)</code></td><td style="text-align: left">upper bound on <code>typeof(data)</code> ensuring <code>predict(model, kop, data...)</code> works</td><td style="text-align: left"><code>Union{}</code></td><td style="text-align: left"><code>AbstractMatrix{&lt;:Real}</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.predict_input_observation_type"><code>LearnAPI.predict_input_observation_type</code></a><code>(algorithm)</code></td><td style="text-align: left">upper bound on <code>typeof(observation)</code> for <code>observation</code> in <code>data</code> ensuring <code>predict(model, kop, data...)</code> works</td><td style="text-align: left"><code>Union{}</code></td><td style="text-align: left"><code>Vector{&lt;:Real}</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.predict_output_scitype"><code>LearnAPI.predict_output_scitype</code></a><code>(algorithm, kind_of_proxy)</code></td><td style="text-align: left">upper bound on <code>scitype(predict(model, ...))</code></td><td style="text-align: left"><code>Any</code></td><td style="text-align: left"><code>AbstractVector{Continuous}</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.predict_output_type"><code>LearnAPI.predict_output_type</code></a><code>(algorithm, kind_of_proxy)</code></td><td style="text-align: left">upper bound on <code>typeof(predict(model, ...))</code></td><td style="text-align: left"><code>Any</code></td><td style="text-align: left"><code>AbstractVector{&lt;:Real}</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.transform_input_scitype"><code>LearnAPI.transform_input_scitype</code></a><code>(algorithm)</code></td><td style="text-align: left">upper bound on <code>scitype(data)</code> ensuring  <code>transform(model, data...)</code> works</td><td style="text-align: left"><code>Union{}</code></td><td style="text-align: left"><code>Table(Continuous)</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.transform_input_observation_scitype"><code>LearnAPI.transform_input_observation_scitype</code></a><code>(algorithm)</code></td><td style="text-align: left">upper bound on <code>scitype(observation)</code> for <code>observation</code> in <code>data</code> ensuring <code>transform(model, data...)</code> works</td><td style="text-align: left"><code>Union{}</code></td><td style="text-align: left"><code>Vector{Continuous}</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.transform_input_type"><code>LearnAPI.transform_input_type</code></a><code>(algorithm)</code></td><td style="text-align: left">upper bound on <code>typeof(data)</code>ensuring <code>transform(model, data...)</code> works</td><td style="text-align: left"><code>Union{}</code></td><td style="text-align: left"><code>AbstractMatrix{&lt;:Real}}</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.transform_input_observation_type"><code>LearnAPI.transform_input_observation_type</code></a><code>(algorithm)</code></td><td style="text-align: left">upper bound on <code>typeof(observation)</code> for <code>observation</code> in <code>data</code> ensuring <code>transform(model, data...)</code> works</td><td style="text-align: left"><code>Union{}</code></td><td style="text-align: left"><code>Vector{Continuous}</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.transform_output_scitype"><code>LearnAPI.transform_output_scitype</code></a><code>(algorithm)</code></td><td style="text-align: left">upper bound on <code>scitype(transform(model, ...))</code></td><td style="text-align: left"><code>Any</code></td><td style="text-align: left"><code>Table(Continuous)</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.transform_output_type"><code>LearnAPI.transform_output_type</code></a><code>(algorithm)</code></td><td style="text-align: left">upper bound on <code>typeof(transform(model, ...))</code></td><td style="text-align: left"><code>Any</code></td><td style="text-align: left"><code>AbstractMatrix{&lt;:Real}</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.predict_or_transform_mutates"><code>LearnAPI.predict_or_transform_mutates</code></a><code>(algorithm)</code></td><td style="text-align: left"><code>true</code> if <code>predict</code> or <code>transform</code> mutates first argument</td><td style="text-align: left"><code>false</code></td><td style="text-align: left"><code>true</code></td></tr></table><p>¹ If the value is <code>0</code>, then the variable in boldface type is not supported and not expected to appear in <code>data</code>. If <code>length(data)</code> is less than the trait value, then <code>data</code> is understood to exclude the variable, but note that <code>fit</code> can have multiple signatures of varying lengths, as in <code>fit(algorithm, X, y)</code> and <code>fit(algorithm, X, y, w)</code>.  A non-zero value is a promise that <code>fit</code> includes a signature of sufficient length to include the variable.</p><h3 id="Derived-Traits"><a class="docs-heading-anchor" href="#Derived-Traits">Derived Traits</a><a id="Derived-Traits-1"></a><a class="docs-heading-anchor-permalink" href="#Derived-Traits" title="Permalink"></a></h3><p>The following convenience methods are provided but not overloadable by new implementations.</p><table><tr><th style="text-align: left">trait</th><th style="text-align: left">return value</th><th style="text-align: left">example</th></tr><tr><td style="text-align: left"><code>LearnAPI.name(algorithm)</code></td><td style="text-align: left">algorithm type name as string</td><td style="text-align: left">&quot;PCA&quot;</td></tr><tr><td style="text-align: left"><code>LearnAPI.is_algorithm(algorithm)</code></td><td style="text-align: left"><code>true</code> if <code>LearnAPI.functions(algorithm)</code> is not empty</td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><a href="@ref"><code>LearnAPI.predict_output_scitypes(algorithm)</code></a></td><td style="text-align: left">dictionary of upper bounds on the scitype of predictions, keyed on subtypes of <a href="../kinds_of_target_proxy/#LearnAPI.KindOfProxy"><code>LearnAPI.KindOfProxy</code></a></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><a href="@ref"><code>LearnAPI.predict_output_types(algorithm)</code></a></td><td style="text-align: left">dictionary of upper bounds on the type of predictions, keyed on subtypes of <a href="../kinds_of_target_proxy/#LearnAPI.KindOfProxy"><code>LearnAPI.KindOfProxy</code></a></td><td style="text-align: left"></td></tr></table><h2 id="Implementation-guide"><a class="docs-heading-anchor" href="#Implementation-guide">Implementation guide</a><a id="Implementation-guide-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-guide" title="Permalink"></a></h2><p>A single-argument trait is declared following this pattern:</p><pre><code class="language-julia hljs">LearnAPI.is_pure_julia(algorithm::MyAlgorithmType) = true</code></pre><p>A shorthand for single-argument traits is available:</p><pre><code class="language-julia hljs">@trait MyAlgorithmType is_pure_julia=true</code></pre><p>Multiple traits can be declared like this:</p><pre><code class="language-julia hljs">@trait(
    MyAlgorithmType,
    is_pure_julia = true,
    pkg_name = &quot;MyPackage&quot;,
)</code></pre><h3 id="The-global-trait-contracts"><a class="docs-heading-anchor" href="#The-global-trait-contracts">The global trait contracts</a><a id="The-global-trait-contracts-1"></a><a class="docs-heading-anchor-permalink" href="#The-global-trait-contracts" title="Permalink"></a></h3><p>To ensure that trait metadata can be stored in an external algorithm registry, LearnAPI.jl requires:</p><ol><li><p><em>Finiteness:</em> The value of a trait is the same for all algorithms with same underlying <code>UnionAll</code> type. That is, even if the type parameters are different, the trait should be the same.  There is an exception if <code>is_composite(algorithm) = true</code>.</p></li><li><p><em>Serializability:</em> The value of any trait can be evaluated without installing any third party package; <code>using LearnAPI</code> should suffice.</p></li></ol><p>Because of 1, combining a lot of functionality into one algorithm (e.g. the algorithm can perform both classification or regression) can mean traits are necessarily less informative (as in <code>LearnAPI.predict_type(algorithm) = Any</code>).</p><h2 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LearnAPI.functions" href="#LearnAPI.functions"><code>LearnAPI.functions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.functions(algorithm)</code></pre><p>Return a tuple of functions that can be sensibly applied to <code>algorithm</code>, or to objects having the same type as <code>algorithm</code>, or to associated models (objects returned by <code>fit(algorithm, ...)</code>. Algorithm traits are excluded.</p><p>In addition to functions, the returned tuple may include expressions, like <code>:(DecisionTree.print_tree)</code>, which reference functions not owned by LearnAPI.jl packages.</p><p>The understanding is that <code>algorithm</code> is a LearnAPI-compliant object whenever this is non-empty.</p><p><strong>Extended help</strong></p><p><strong>New implementations</strong></p><p>All new implementations must overload this trait. Here&#39;s a checklist for elements in the return value:</p><table><tr><th style="text-align: right">function</th><th style="text-align: right">needs explicit  implementation?</th><th style="text-align: right">include in returned tuple?</th></tr><tr><td style="text-align: right"><code>fit</code></td><td style="text-align: right">no</td><td style="text-align: right">yes</td></tr><tr><td style="text-align: right"><code>obsfit</code></td><td style="text-align: right">yes</td><td style="text-align: right">yes</td></tr><tr><td style="text-align: right"><code>minimize</code></td><td style="text-align: right">optional</td><td style="text-align: right">yes</td></tr><tr><td style="text-align: right"><code>predict</code></td><td style="text-align: right">no</td><td style="text-align: right">if <code>obspredict</code> is implemented</td></tr><tr><td style="text-align: right"><code>obspredict</code></td><td style="text-align: right">optional</td><td style="text-align: right">if implemented</td></tr><tr><td style="text-align: right"><code>transform</code></td><td style="text-align: right">no</td><td style="text-align: right">if <code>obstransform</code> is implemented</td></tr><tr><td style="text-align: right"><code>obstransform</code></td><td style="text-align: right">optional</td><td style="text-align: right">if implemented</td></tr><tr><td style="text-align: right"><code>obs</code></td><td style="text-align: right">optional</td><td style="text-align: right">yes</td></tr><tr><td style="text-align: right"><code>inverse_transform</code></td><td style="text-align: right">optional</td><td style="text-align: right">if implemented</td></tr><tr><td style="text-align: right"><code>LearnAPI.algorithm</code></td><td style="text-align: right">yes</td><td style="text-align: right">yes</td></tr></table><p>Also include any implemented accessor functions. The LearnAPI.jl accessor functions are: <a href="../accessor_functions/#LearnAPI.extras"><code>LearnAPI.extras</code></a>, <a href="../accessor_functions/#LearnAPI.algorithm"><code>LearnAPI.algorithm</code></a>, <a href="../accessor_functions/#LearnAPI.coefficients"><code>LearnAPI.coefficients</code></a>, <a href="../accessor_functions/#LearnAPI.intercept"><code>LearnAPI.intercept</code></a>, <a href="../accessor_functions/#LearnAPI.tree"><code>LearnAPI.tree</code></a>, <a href="../accessor_functions/#LearnAPI.trees"><code>LearnAPI.trees</code></a>, <a href="../accessor_functions/#LearnAPI.feature_importances"><code>LearnAPI.feature_importances</code></a>, <a href="../accessor_functions/#LearnAPI.training_labels"><code>LearnAPI.training_labels</code></a>, <a href="../accessor_functions/#LearnAPI.training_losses"><code>LearnAPI.training_losses</code></a>, <a href="../accessor_functions/#LearnAPI.training_scores"><code>LearnAPI.training_scores</code></a> and <a href="../accessor_functions/#LearnAPI.components"><code>LearnAPI.components</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/50e786d122cb1b0ddefc64f71d77e468c44e03de/src/traits.jl#L51-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LearnAPI.kinds_of_proxy" href="#LearnAPI.kinds_of_proxy"><code>LearnAPI.kinds_of_proxy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.kinds_of_proxy(algorithm)</code></pre><p>Returns an tuple of instances, <code>kind</code>, for which for which <code>predict(algorithm, kind, data...)</code> has a guaranteed implementation. Each such <code>kind</code> subtypes <a href="../kinds_of_target_proxy/#LearnAPI.KindOfProxy"><code>LearnAPI.KindOfProxy</code></a>. Examples are <code>LiteralTarget()</code> (for predicting actual target values) and <code>Distributions()</code> (for predicting probability mass/density functions).</p><p>See also <a href="../predict_transform/#LearnAPI.predict"><code>LearnAPI.predict</code></a>, <a href="../kinds_of_target_proxy/#LearnAPI.KindOfProxy"><code>LearnAPI.KindOfProxy</code></a>.</p><p><strong>Extended help</strong></p><p><strong>New implementations</strong></p><p>Implementation is optional but recommended whenever <code>predict</code> is overloaded.</p><p>Elements of the returned tuple must be one of these: <code>ConfidenceInterval</code>, <code>Continuous</code>, <code>Distribution</code>, <code>LabelAmbiguous</code>, <code>LabelAmbiguousDistribution</code>, <code>LabelAmbiguousSampleable</code>, <code>LiteralTarget</code>, <code>LogDistribution</code>, <code>LogProbability</code>, <code>OutlierScore</code>, <code>Parametric</code>, <code>ProbabilisticSet</code>, <code>Probability</code>, <code>Sampleable</code>, <code>Set</code>, <code>SurvivalDistribution</code>, <code>SurvivalFunction</code>, <code>IID</code>, <code>JointDistribution</code>, <code>JointLogDistribution</code> and <code>JointSampleable</code>.</p><p>Suppose, for example, we have the following implementation of a supervised learner returning only probabilistic predictions:</p><pre><code class="language-julia hljs">LearnAPI.predict(algorithm::MyNewAlgorithmType, LearnAPI.Distribution(), Xnew) = ...</code></pre><p>Then we can declare</p><pre><code class="language-julia hljs">@trait MyNewAlgorithmType kinds_of_proxy = (LearnaAPI.Distribution(),)</code></pre><p>For more on target variables and target proxies, refer to the LearnAPI documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/50e786d122cb1b0ddefc64f71d77e468c44e03de/src/traits.jl#L91-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LearnAPI.position_of_target" href="#LearnAPI.position_of_target"><code>LearnAPI.position_of_target</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.position_of_target(algorithm)</code></pre><p>Return the expected position of the target variable within <code>data</code> in calls of the form <a href="../fit/#LearnAPI.fit"><code>LearnAPI.fit</code></a><code>(algorithm, verbosity, data...)</code>.</p><p>If this number is <code>0</code>, then no target is expected. If this number exceeds <code>length(data)</code>, then <code>data</code> is understood to exclude the target variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/50e786d122cb1b0ddefc64f71d77e468c44e03de/src/traits.jl#L127-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LearnAPI.position_of_weights" href="#LearnAPI.position_of_weights"><code>LearnAPI.position_of_weights</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.position_of_weights(algorithm)</code></pre><p>Return the expected position of per-observation weights within <code>data</code> in calls of the form <a href="../fit/#LearnAPI.fit"><code>LearnAPI.fit</code></a><code>(algorithm, data...)</code>.</p><p>If this number is <code>0</code>, then no weights are expected. If this number exceeds <code>length(data)</code>, then <code>data</code> is understood to exclude weights, which are assumed to be uniform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/50e786d122cb1b0ddefc64f71d77e468c44e03de/src/traits.jl#L139-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LearnAPI.descriptors" href="#LearnAPI.descriptors"><code>LearnAPI.descriptors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.descriptors(algorithm)</code></pre><p>Lists one or more suggestive algorithm descriptors from this list: <code>:regression</code>, <code>:classification</code>, <code>:clustering</code>, <code>:gradient_descent</code>, <code>:iterative_algorithms</code>, <code>:incremental_algorithms</code>, <code>:dimension_reduction</code>, <code>:encoders</code>, <code>:static_algorithms</code>, <code>:missing_value_imputation</code>, <code>:ensemble_algorithms</code>, <code>:wrappers</code>, <code>:time_series_forecasting</code>, <code>:time_series_classification</code>, <code>:survival_analysis</code>, <code>:distribution_fitters</code>, <code>:Bayesian_algorithms</code>, <code>:outlier_detection</code>, <code>:collaborative_filtering</code>, <code>:text_analysis</code>, <code>:audio_analysis</code>, <code>:natural_language_processing</code>, <code>:image_processing</code> (do <code>LearnAPI.descriptors()</code> to reproduce).</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The value of this trait guarantees no particular behavior. The trait is intended for informal classification purposes only.</p></div></div><p><strong>New implementations</strong></p><p>This trait should return a tuple of symbols, as in <code>(:classifier, :probabilistic)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/50e786d122cb1b0ddefc64f71d77e468c44e03de/src/traits.jl#L180-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LearnAPI.is_pure_julia" href="#LearnAPI.is_pure_julia"><code>LearnAPI.is_pure_julia</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.is_pure_julia(algorithm)</code></pre><p>Returns <code>true</code> if training <code>algorithm</code> requires evaluation of pure Julia code only.</p><p><strong>New implementations</strong></p><p>The fallback is <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/50e786d122cb1b0ddefc64f71d77e468c44e03de/src/traits.jl#L197-L206">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LearnAPI.pkg_name" href="#LearnAPI.pkg_name"><code>LearnAPI.pkg_name</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.pkg_name(algorithm)</code></pre><p>Return the name of the package module which supplies the core training algorithm for <code>algorithm</code>.  This is not necessarily the package providing the LearnAPI interface.</p><p>Returns <code>&quot;unknown&quot;</code> if the algorithm implementation has failed to overload the trait. </p><p><strong>New implementations</strong></p><p>Must return a string, as in <code>&quot;DecisionTree&quot;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/50e786d122cb1b0ddefc64f71d77e468c44e03de/src/traits.jl#L209-L222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LearnAPI.pkg_license" href="#LearnAPI.pkg_license"><code>LearnAPI.pkg_license</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.pkg_license(algorithm)</code></pre><p>Return the name of the software license, such as <code>&quot;MIT&quot;</code>, applying to the package where the core algorithm for <code>algorithm</code> is implemented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/50e786d122cb1b0ddefc64f71d77e468c44e03de/src/traits.jl#L225-L231">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LearnAPI.doc_url" href="#LearnAPI.doc_url"><code>LearnAPI.doc_url</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.doc_url(algorithm)</code></pre><p>Return a url where the core algorithm for <code>algorithm</code> is documented.</p><p>Returns <code>&quot;unknown&quot;</code> if the algorithm implementation has failed to overload the trait. </p><p><strong>New implementations</strong></p><p>Must return a string, such as <code>&quot;https://en.wikipedia.org/wiki/Decision_tree_learning&quot;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/50e786d122cb1b0ddefc64f71d77e468c44e03de/src/traits.jl#L234-L245">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LearnAPI.load_path" href="#LearnAPI.load_path"><code>LearnAPI.load_path</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.load_path(algorithm)</code></pre><p>Return a string indicating where the <code>struct</code> for <code>typeof(algorithm)</code> can be found, beginning with the name of the package module defining it. For example, a return value of <code>&quot;FastTrees.LearnAPI.DecisionTreeClassifier&quot;</code> means the following julia code will return the algorithm type:</p><pre><code class="language-julia hljs">import FastTrees
FastTrees.LearnAPI.DecisionTreeClassifier</code></pre><p>Returns <code>&quot;unknown&quot;</code> if the algorithm implementation has failed to overload the trait. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/50e786d122cb1b0ddefc64f71d77e468c44e03de/src/traits.jl#L248-L264">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LearnAPI.is_composite" href="#LearnAPI.is_composite"><code>LearnAPI.is_composite</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.is_composite(algorithm)</code></pre><p>Returns <code>true</code> if one or more properties (fields) of <code>algorithm</code> may themselves be algorithms, and <code>false</code> otherwise.</p><p>See also <code>[LearnAPI.components]</code>(@ref).</p><p><strong>New implementations</strong></p><p>This trait should be overloaded if one or more properties (fields) of <code>algorithm</code> may take algorithm values. Fallback return value is <code>false</code>. The keyword constructor for such an algorithm need not prescribe defaults for algorithm-valued properties. Implementation of the accessor function <code>[LearnAPI.components]</code>(@ref) is recommended.</p><p>The value of the trait must depend only on the type of <code>algorithm</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/50e786d122cb1b0ddefc64f71d77e468c44e03de/src/traits.jl#L268-L286">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LearnAPI.human_name" href="#LearnAPI.human_name"><code>LearnAPI.human_name</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.human_name(algorithm)</code></pre><p>A human-readable string representation of <code>typeof(algorithm)</code>. Primarily intended for auto-generation of documentation.</p><p><strong>New implementations</strong></p><p>Optional. A fallback takes the type name, inserts spaces and removes capitalization. For example, <code>KNNRegressor</code> becomes <code>&quot;knn regressor&quot;</code>. Better would be to overload the trait to return <code>&quot;K-nearest neighbors regressor&quot;</code>. Ideally, this is a &quot;concrete&quot; noun like <code>&quot;ridge regressor&quot;</code> rather than an &quot;abstract&quot; noun like <code>&quot;ridge regression&quot;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/50e786d122cb1b0ddefc64f71d77e468c44e03de/src/traits.jl#L289-L302">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LearnAPI.iteration_parameter" href="#LearnAPI.iteration_parameter"><code>LearnAPI.iteration_parameter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.iteration_parameter(algorithm)</code></pre><p>The name of the iteration parameter of <code>algorithm</code>, or <code>nothing</code> if the algorithm is not iterative.</p><p><strong>New implementations</strong></p><p>Implement if algorithm is iterative. Returns a symbol or <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/50e786d122cb1b0ddefc64f71d77e468c44e03de/src/traits.jl#L320-L330">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LearnAPI.fit_scitype" href="#LearnAPI.fit_scitype"><code>LearnAPI.fit_scitype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.fit_scitype(algorithm)</code></pre><p>Return an upper bound on the scitype of <code>data</code> guaranteed to work when calling <code>fit(algorithm, data...)</code>.</p><p>Specifically, if the return value is <code>S</code> and <code>ScientificTypes.scitype(data) &lt;: S</code>, then all the following calls are guaranteed to work:</p><pre><code class="language-julia hljs">fit(algorithm, data...)
obsdata = obs(fit, algorithm, data...)
fit(algorithm, Obs(), obsdata)</code></pre><p>See also <a href="#LearnAPI.fit_type"><code>LearnAPI.fit_type</code></a>, <a href="#LearnAPI.fit_observation_scitype"><code>LearnAPI.fit_observation_scitype</code></a>, <a href="#LearnAPI.fit_observation_type"><code>LearnAPI.fit_observation_type</code></a>.</p><p><strong>New implementations</strong></p><p>Optional. The fallback return value is <code>Union{}</code>.  Ordinarily, at most one of the following should be overloaded for given algorithm <code>LearnAPI.fit_scitype</code>, <code>LearnAPI.fit_type</code>, <code>LearnAPI.fit_observation_scitype</code>, <code>LearnAPI.fit_observation_type</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/50e786d122cb1b0ddefc64f71d77e468c44e03de/src/traits.jl#L334-L356">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LearnAPI.fit_type" href="#LearnAPI.fit_type"><code>LearnAPI.fit_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.fit_type(algorithm)</code></pre><p>Return an upper bound on the type of <code>data</code> guaranteed to work when calling <code>fit(algorithm, data...)</code>.</p><p>Specifically, if the return value is <code>T</code> and <code>typeof(data) &lt;: T</code>, then all the following calls are guaranteed to work:</p><pre><code class="language-julia hljs">fit(algorithm, data...)
obsdata = obs(fit, algorithm, data...)
fit(algorithm, Obs(), obsdata)</code></pre><p>See also <a href="#LearnAPI.fit_scitype"><code>LearnAPI.fit_scitype</code></a>, <a href="#LearnAPI.fit_observation_type"><code>LearnAPI.fit_observation_type</code></a>. <a href="#LearnAPI.fit_observation_scitype"><code>LearnAPI.fit_observation_scitype</code></a></p><p><strong>New implementations</strong></p><p>Optional. The fallback return value is <code>Union{}</code>. Ordinarily, at most one of the following should be overloaded for given algorithm <code>LearnAPI.fit_scitype</code>, <code>LearnAPI.fit_type</code>, <code>LearnAPI.fit_observation_scitype</code>, <code>LearnAPI.fit_observation_type</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/50e786d122cb1b0ddefc64f71d77e468c44e03de/src/traits.jl#L394-L416">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LearnAPI.fit_observation_scitype" href="#LearnAPI.fit_observation_scitype"><code>LearnAPI.fit_observation_scitype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.fit_observation_scitype(algorithm)</code></pre><p>Return an upper bound on the scitype of observations guaranteed to work when calling <code>fit(algorithm, data...)</code>, independent of the type/scitype of the data container itself. Here &quot;observations&quot; is in the sense of MLUtils.jl. Assuming this trait has value different from <code>Union{}</code> the understanding is that <code>data</code> implements the MLUtils.jl <code>getobs</code>/<code>numobs</code> interface.</p><p>Specifically, denoting the type returned above by <code>S</code>, supposing <code>S != Union{}</code>, and that user supplies <code>data</code> satisfying</p><pre><code class="language-julia hljs">ScientificTypes.scitype(MLUtils.getobs(data, i)) &lt;: S</code></pre><p>for any valid index <code>i</code>, then all the following are guaranteed to work:</p><pre><code class="language-julia hljs">fit(algorithm, data....)
obsdata = obs(fit, algorithm, data...)
fit(algorithm, Obs(), obsdata)</code></pre><p>See also See also <a href="#LearnAPI.fit_type"><code>LearnAPI.fit_type</code></a>, <a href="#LearnAPI.fit_scitype"><code>LearnAPI.fit_scitype</code></a>, <a href="#LearnAPI.fit_observation_type"><code>LearnAPI.fit_observation_type</code></a>.</p><p><strong>New implementations</strong></p><p>Optional. The fallback return value is <code>Union{}</code>. Ordinarily, at most one of the following should be overloaded for given algorithm <code>LearnAPI.fit_scitype</code>, <code>LearnAPI.fit_type</code>, <code>LearnAPI.fit_observation_scitype</code>, <code>LearnAPI.fit_observation_type</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/50e786d122cb1b0ddefc64f71d77e468c44e03de/src/traits.jl#L359-L391">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LearnAPI.fit_observation_type" href="#LearnAPI.fit_observation_type"><code>LearnAPI.fit_observation_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.fit_observation_type(algorithm)</code></pre><p>Return an upper bound on the type of observations guaranteed to work when calling <code>fit(algorithm, data...)</code>, independent of the type/scitype of the data container itself. Here &quot;observations&quot; is in the sense of MLUtils.jl. Assuming this trait has value different from <code>Union{}</code> the understanding is that <code>data</code> implements the MLUtils.jl <code>getobs</code>/<code>numobs</code> interface.</p><p>Specifically, denoting the type returned above by <code>T</code>, supposing <code>T != Union{}</code>, and that user supplies <code>data</code> satisfying</p><pre><code class="language-julia hljs">typeof(MLUtils.getobs(data, i)) &lt;: T</code></pre><p>for any valid index <code>i</code>, then the following is guaranteed to work:</p><pre><code class="language-julia hljs">fit(algorithm, data....)
obsdata = obs(fit, algorithm, data...)
fit(algorithm, Obs(), obsdata)</code></pre><p>See also See also <a href="#LearnAPI.fit_type"><code>LearnAPI.fit_type</code></a>, <a href="#LearnAPI.fit_scitype"><code>LearnAPI.fit_scitype</code></a>, <a href="#LearnAPI.fit_observation_scitype"><code>LearnAPI.fit_observation_scitype</code></a>.</p><p><strong>New implementations</strong></p><p>Optional. The fallback return value is <code>Union{}</code>. Ordinarily, at most one of the following should be overloaded for given algorithm <code>LearnAPI.fit_scitype</code>, <code>LearnAPI.fit_type</code>, <code>LearnAPI.fit_observation_scitype</code>, <code>LearnAPI.fit_observation_type</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/50e786d122cb1b0ddefc64f71d77e468c44e03de/src/traits.jl#L419-L450">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LearnAPI.predict_input_scitype" href="#LearnAPI.predict_input_scitype"><code>LearnAPI.predict_input_scitype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> LearnAPI.predict_input_scitype(algorithm)</code></pre><p>Return an upper bound on the scitype of <code>data</code> guaranteed to work in the call  <code>predict(algorithm, kind_of_proxy, data...)</code>.</p><p>Specifically, if <code>S</code> is the value returned and <code>ScientificTypes.scitype(data) &lt;: S</code>,  then the following is guaranteed to work:</p><p><code>julia  predict(model, kind_of_proxy, data...)  obsdata = obs(predict, algorithm, data...)  predict(model, kind_of_proxy, Obs(), obsdata)</code>  whenever <code>algorithm = LearnAPI.algorithm(model)</code>.</p><p>See also <a href="#LearnAPI.predict_input_type"><code>LearnAPI.predict_input_type</code></a>.</p><p><strong>New implementations</strong></p><p>Implementation is optional. The fallback return value is <code>Union{}</code>. Ordinarily, at most one of the following should be overloaded for given algorithm <code>LearnAPI.predict_scitype</code>, <code>LearnAPI.predict_type</code>, <code>LearnAPI.predict_observation_scitype</code>, <code>LearnAPI.predict_observation_type</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/50e786d122cb1b0ddefc64f71d77e468c44e03de/src/traits.jl#L611-L633">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LearnAPI.predict_input_observation_scitype" href="#LearnAPI.predict_input_observation_scitype"><code>LearnAPI.predict_input_observation_scitype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.predict_observation_scitype(algorithm)</code></pre><p>Return an upper bound on the scitype of observations guaranteed to work when calling <code>predict(model, kind_of_proxy, data...)</code>, independent of the type/scitype of the data container itself. Here &quot;observations&quot; is in the sense of MLUtils.jl. Assuming this trait has value different from <code>Union{}</code> the understanding is that <code>data</code> implements the MLUtils.jl <code>getobs</code>/<code>numobs</code> interface.</p><p>Specifically, denoting the type returned above by <code>S</code>, supposing <code>S != Union{}</code>, and that user supplies <code>data</code> satisfying</p><pre><code class="language-julia hljs">ScientificTypes.scitype(MLUtils.getobs(data, i)) &lt;: S</code></pre><p>for any valid index <code>i</code>, then all the following are guaranteed to work:</p><pre><code class="language-julia hljs">predict(model, kind_of_proxy, data...)
obsdata = obs(predict, algorithm, data...)
predict(model, kind_of_proxy, Obs(), obsdata)</code></pre><p>whenever <code>algorithm = LearnAPI.algorithm(model)</code>.</p><p>See also See also <a href="#LearnAPI.fit_type"><code>LearnAPI.fit_type</code></a>, <a href="#LearnAPI.fit_scitype"><code>LearnAPI.fit_scitype</code></a>, <a href="#LearnAPI.fit_observation_type"><code>LearnAPI.fit_observation_type</code></a>.</p><p><strong>New implementations</strong></p><p>Optional. The fallback return value is <code>Union{}</code>. Ordinarily, at most one of the following should be overloaded for given algorithm <code>LearnAPI.predict_scitype</code>, <code>LearnAPI.predict_type</code>, <code>LearnAPI.predict_observation_scitype</code>, <code>LearnAPI.predict_observation_type</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/50e786d122cb1b0ddefc64f71d77e468c44e03de/src/traits.jl#L614-L646">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LearnAPI.predict_input_type" href="#LearnAPI.predict_input_type"><code>LearnAPI.predict_input_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.predict_input_type(algorithm)</code></pre><p>Return an upper bound on the type of <code>data</code> guaranteed to work in the call <code>predict(algorithm, kind_of_proxy, data...)</code>.</p><p>Specifically, if <code>T</code> is the value returned and <code>typeof(data) &lt;: T</code>, then the following is guaranteed to work:</p><pre><code class="language-julia hljs">predict(model, kind_of_proxy, data...)
obsdata = obs(predict, model, data...)
predict(model, kind_of_proxy, Obs(), obsdata)</code></pre><p>See also <a href="#LearnAPI.predict_input_scitype"><code>LearnAPI.predict_input_scitype</code></a>.</p><p><strong>New implementations</strong></p><p>Implementation is optional. The fallback return value is <code>Union{}</code>. Should not be overloaded if <code>LearnAPI.predict_input_scitype</code> is overloaded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/50e786d122cb1b0ddefc64f71d77e468c44e03de/src/traits.jl#L617-L639">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LearnAPI.predict_input_observation_type" href="#LearnAPI.predict_input_observation_type"><code>LearnAPI.predict_input_observation_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.predict_observation_type(algorithm)</code></pre><p>Return an upper bound on the type of observations guaranteed to work when calling <code>predict(model, kind_of_proxy, data...)</code>, independent of the type/scitype of the data container itself. Here &quot;observations&quot; is in the sense of MLUtils.jl. Assuming this trait has value different from <code>Union{}</code> the understanding is that <code>data</code> implements the MLUtils.jl <code>getobs</code>/<code>numobs</code> interface.</p><p>Specifically, denoting the type returned above by <code>T</code>, supposing <code>T != Union{}</code>, and that user supplies <code>data</code> satisfying</p><pre><code class="language-julia hljs">typeof(MLUtils.getobs(data, i)) &lt;: T</code></pre><p>for any valid index <code>i</code>, then all the following are guaranteed to work:</p><pre><code class="language-julia hljs">predict(model, kind_of_proxy, data...)
obsdata = obs(predict, algorithm, data...)
predict(model, kind_of_proxy, Obs(), obsdata)</code></pre><p>whenever <code>algorithm = LearnAPI.algorithm(model)</code>.</p><p>See also See also <a href="#LearnAPI.fit_type"><code>LearnAPI.fit_type</code></a>, <a href="#LearnAPI.fit_scitype"><code>LearnAPI.fit_scitype</code></a>, <a href="#LearnAPI.fit_observation_type"><code>LearnAPI.fit_observation_type</code></a>.</p><p><strong>New implementations</strong></p><p>Optional. The fallback return value is <code>Union{}</code>. Ordinarily, at most one of the following should be overloaded for given algorithm <code>LearnAPI.predict_scitype</code>, <code>LearnAPI.predict_type</code>, <code>LearnAPI.predict_observation_scitype</code>, <code>LearnAPI.predict_observation_type</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/50e786d122cb1b0ddefc64f71d77e468c44e03de/src/traits.jl#L620-L652">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LearnAPI.predict_output_scitype" href="#LearnAPI.predict_output_scitype"><code>LearnAPI.predict_output_scitype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.predict_output_scitype(algorithm)</code></pre><p>Return a dictionary of upper bounds on the scitype of predictions, keyed on concrete subtypes of <a href="../kinds_of_target_proxy/#LearnAPI.KindOfProxy"><code>LearnAPI.KindOfProxy</code></a>. Each of these subtypes represents a different form of target prediction (<code>LiteralTarget</code>, <code>Distribution</code>, <code>SurvivalFunction</code>, etc) possibly supported by <code>algorithm</code>, but the existence of a key does not guarantee that form is supported.</p><p>As an example, if</p><pre><code class="nohighlight hljs">ŷ = LearnAPI.predict(model, LearnAPI.Distribution(), data...)</code></pre><p>successfully returns (i.e., <code>algorithm</code> supports predictions of target probability distributions) then the following is guaranteed to hold:</p><pre><code class="nohighlight hljs">scitype(ŷ) &lt;: LearnAPI.predict_output_scitypes(algorithm)[LearnAPI.Distribution]</code></pre><p>See also <a href="../kinds_of_target_proxy/#LearnAPI.KindOfProxy"><code>LearnAPI.KindOfProxy</code></a>, <a href="../predict_transform/#LearnAPI.predict"><code>LearnAPI.predict</code></a>, <a href="#LearnAPI.predict_input_scitype"><code>LearnAPI.predict_input_scitype</code></a>.</p><p><strong>New implementations</strong></p><p>This single argument trait should not be overloaded. Instead, overload <a href="#LearnAPI.predict_output_scitype"><code>LearnAPI.predict_output_scitype</code></a>(algorithm, kind<em>of</em>proxy).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/50e786d122cb1b0ddefc64f71d77e468c44e03de/src/traits.jl#L729-L755">source</a></section><section><div><pre><code class="language-julia hljs">LearnAPI.predict_output_scitype(algorithm, kind_of_proxy::KindOfProxy)</code></pre><p>Return an upper bound for the scitypes of predictions of the specified form where supported, and otherwise return <code>Any</code>. For example, if</p><pre><code class="nohighlight hljs">ŷ = LearnAPI.predict(model, LearnAPI.Distribution(), data...)</code></pre><p>successfully returns (i.e., <code>algorithm</code> supports predictions of target probability distributions) then the following is guaranteed to hold:</p><pre><code class="nohighlight hljs">scitype(ŷ) &lt;: LearnAPI.predict_output_scitype(algorithm, LearnAPI.Distribution())</code></pre><p><strong>Note.</strong> This trait has a single-argument &quot;convenience&quot; version <code>LearnAPI.predict_output_scitype(algorithm)</code> derived from this one, which returns a dictionary keyed on target proxy types.</p><p>See also <a href="../kinds_of_target_proxy/#LearnAPI.KindOfProxy"><code>LearnAPI.KindOfProxy</code></a>, <a href="../predict_transform/#LearnAPI.predict"><code>LearnAPI.predict</code></a>, <a href="#LearnAPI.predict_input_scitype"><code>LearnAPI.predict_input_scitype</code></a>.</p><p><strong>New implementations</strong></p><p>Overloading the trait is optional. Here&#39;s a sample implementation for a supervised regressor type <code>MyRgs</code> that only predicts actual values of the target:</p><pre><code class="language-julia hljs">@trait MyRgs predict_output_scitype = AbstractVector{ScientificTypesBase.Continuous}</code></pre><p>The fallback method returns <code>Any</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/50e786d122cb1b0ddefc64f71d77e468c44e03de/src/traits.jl#L685-L716">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LearnAPI.predict_output_type" href="#LearnAPI.predict_output_type"><code>LearnAPI.predict_output_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.predict_output_type(algorithm)</code></pre><p>Return a dictionary of upper bounds on the type of predictions, keyed on concrete subtypes of <a href="../kinds_of_target_proxy/#LearnAPI.KindOfProxy"><code>LearnAPI.KindOfProxy</code></a>. Each of these subtypes represents a different form of target prediction (<code>LiteralTarget</code>, <code>Distribution</code>, <code>SurvivalFunction</code>, etc) possibly supported by <code>algorithm</code>, but the existence of a key does not guarantee that form is supported.</p><p>As an example, if</p><pre><code class="nohighlight hljs">ŷ = LearnAPI.predict(model, LearnAPI.Distribution(), data...)</code></pre><p>successfully returns (i.e., <code>algorithm</code> supports predictions of target probability distributions) then the following is guaranteed to hold:</p><pre><code class="nohighlight hljs">type(ŷ) &lt;: LearnAPI.predict_output_types(algorithm)[LearnAPI.Distribution]</code></pre><p>See also <a href="../kinds_of_target_proxy/#LearnAPI.KindOfProxy"><code>LearnAPI.KindOfProxy</code></a>, <a href="../predict_transform/#LearnAPI.predict"><code>LearnAPI.predict</code></a>, <a href="#LearnAPI.predict_input_type"><code>LearnAPI.predict_input_type</code></a>.</p><p><strong>New implementations</strong></p><p>This single argument trait should not be overloaded. Instead, overload <a href="#LearnAPI.predict_output_type"><code>LearnAPI.predict_output_type</code></a>(algorithm, kind<em>of</em>proxy).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/50e786d122cb1b0ddefc64f71d77e468c44e03de/src/traits.jl#L734-L760">source</a></section><section><div><pre><code class="language-julia hljs">LearnAPI.predict_output_type(algorithm, kind_of_proxy::KindOfProxy)</code></pre><p>Return an upper bound for the types of predictions of the specified form where supported, and otherwise return <code>Any</code>. For example, if</p><pre><code class="nohighlight hljs">ŷ = LearnAPI.predict(model, LearnAPI.Distribution(), data...)</code></pre><p>successfully returns (i.e., <code>algorithm</code> supports predictions of target probability distributions) then the following is guaranteed to hold:</p><pre><code class="nohighlight hljs">type(ŷ) &lt;: LearnAPI.predict_output_type(algorithm, LearnAPI.Distribution())</code></pre><p><strong>Note.</strong> This trait has a single-argument &quot;convenience&quot; version <code>LearnAPI.predict_output_type(algorithm)</code> derived from this one, which returns a dictionary keyed on target proxy types.</p><p>See also <a href="../kinds_of_target_proxy/#LearnAPI.KindOfProxy"><code>LearnAPI.KindOfProxy</code></a>, <a href="../predict_transform/#LearnAPI.predict"><code>LearnAPI.predict</code></a>, <a href="#LearnAPI.predict_input_type"><code>LearnAPI.predict_input_type</code></a>.</p><p><strong>New implementations</strong></p><p>Overloading the trait is optional. Here&#39;s a sample implementation for a supervised regressor type <code>MyRgs</code> that only predicts actual values of the target:</p><pre><code class="language-julia hljs">@trait MyRgs predict_output_type = AbstractVector{ScientificTypesBase.Continuous}</code></pre><p>The fallback method returns <code>Any</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/50e786d122cb1b0ddefc64f71d77e468c44e03de/src/traits.jl#L688-L719">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LearnAPI.transform_input_scitype" href="#LearnAPI.transform_input_scitype"><code>LearnAPI.transform_input_scitype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> LearnAPI.transform_input_scitype(algorithm)</code></pre><p>Return an upper bound on the scitype of <code>data</code> guaranteed to work in the call  <code>transform(algorithm, data...)</code>.</p><p>Specifically, if <code>S</code> is the value returned and <code>ScientificTypes.scitype(data) &lt;: S</code>,  then the following is guaranteed to work:</p><p><code>julia  transform(model, data...)  obsdata = obs(transform, algorithm, data...)  transform(model, Obs(), obsdata)</code>  whenever <code>algorithm = LearnAPI.algorithm(model)</code>.</p><p>See also <a href="#LearnAPI.transform_input_type"><code>LearnAPI.transform_input_type</code></a>.</p><p><strong>New implementations</strong></p><p>Implementation is optional. The fallback return value is <code>Union{}</code>. Ordinarily, at most one of the following should be overloaded for given algorithm <code>LearnAPI.transform_scitype</code>, <code>LearnAPI.transform_type</code>, <code>LearnAPI.transform_observation_scitype</code>, <code>LearnAPI.transform_observation_type</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/50e786d122cb1b0ddefc64f71d77e468c44e03de/src/traits.jl#L629-L651">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LearnAPI.transform_input_observation_scitype" href="#LearnAPI.transform_input_observation_scitype"><code>LearnAPI.transform_input_observation_scitype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.transform_observation_scitype(algorithm)</code></pre><p>Return an upper bound on the scitype of observations guaranteed to work when calling <code>transform(model, data...)</code>, independent of the type/scitype of the data container itself. Here &quot;observations&quot; is in the sense of MLUtils.jl. Assuming this trait has value different from <code>Union{}</code> the understanding is that <code>data</code> implements the MLUtils.jl <code>getobs</code>/<code>numobs</code> interface.</p><p>Specifically, denoting the type returned above by <code>S</code>, supposing <code>S != Union{}</code>, and that user supplies <code>data</code> satisfying</p><pre><code class="language-julia hljs">ScientificTypes.scitype(MLUtils.getobs(data, i)) &lt;: S</code></pre><p>for any valid index <code>i</code>, then all the following are guaranteed to work:</p><pre><code class="language-julia hljs">transform(model, data...)
obsdata = obs(transform, algorithm, data...)
transform(model, Obs(), obsdata)</code></pre><p>whenever <code>algorithm = LearnAPI.algorithm(model)</code>.</p><p>See also See also <a href="#LearnAPI.fit_type"><code>LearnAPI.fit_type</code></a>, <a href="#LearnAPI.fit_scitype"><code>LearnAPI.fit_scitype</code></a>, <a href="#LearnAPI.fit_observation_type"><code>LearnAPI.fit_observation_type</code></a>.</p><p><strong>New implementations</strong></p><p>Optional. The fallback return value is <code>Union{}</code>. Ordinarily, at most one of the following should be overloaded for given algorithm <code>LearnAPI.transform_scitype</code>, <code>LearnAPI.transform_type</code>, <code>LearnAPI.transform_observation_scitype</code>, <code>LearnAPI.transform_observation_type</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/50e786d122cb1b0ddefc64f71d77e468c44e03de/src/traits.jl#L632-L664">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LearnAPI.transform_input_type" href="#LearnAPI.transform_input_type"><code>LearnAPI.transform_input_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.transform_input_type(algorithm)</code></pre><p>Return an upper bound on the type of <code>data</code> guaranteed to work in the call <code>transform(algorithm, data...)</code>.</p><p>Specifically, if <code>T</code> is the value returned and <code>typeof(data) &lt;: T</code>, then the following is guaranteed to work:</p><pre><code class="language-julia hljs">transform(model, data...)
obsdata = obs(transform, model, data...)
transform(model, Obs(), obsdata)</code></pre><p>See also <a href="#LearnAPI.transform_input_scitype"><code>LearnAPI.transform_input_scitype</code></a>.</p><p><strong>New implementations</strong></p><p>Implementation is optional. The fallback return value is <code>Union{}</code>. Should not be overloaded if <code>LearnAPI.transform_input_scitype</code> is overloaded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/50e786d122cb1b0ddefc64f71d77e468c44e03de/src/traits.jl#L635-L657">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LearnAPI.transform_input_observation_type" href="#LearnAPI.transform_input_observation_type"><code>LearnAPI.transform_input_observation_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.transform_observation_type(algorithm)</code></pre><p>Return an upper bound on the type of observations guaranteed to work when calling <code>transform(model, data...)</code>, independent of the type/scitype of the data container itself. Here &quot;observations&quot; is in the sense of MLUtils.jl. Assuming this trait has value different from <code>Union{}</code> the understanding is that <code>data</code> implements the MLUtils.jl <code>getobs</code>/<code>numobs</code> interface.</p><p>Specifically, denoting the type returned above by <code>T</code>, supposing <code>T != Union{}</code>, and that user supplies <code>data</code> satisfying</p><pre><code class="language-julia hljs">typeof(MLUtils.getobs(data, i)) &lt;: T</code></pre><p>for any valid index <code>i</code>, then all the following are guaranteed to work:</p><pre><code class="language-julia hljs">transform(model, data...)
obsdata = obs(transform, algorithm, data...)
transform(model, Obs(), obsdata)</code></pre><p>whenever <code>algorithm = LearnAPI.algorithm(model)</code>.</p><p>See also See also <a href="#LearnAPI.fit_type"><code>LearnAPI.fit_type</code></a>, <a href="#LearnAPI.fit_scitype"><code>LearnAPI.fit_scitype</code></a>, <a href="#LearnAPI.fit_observation_type"><code>LearnAPI.fit_observation_type</code></a>.</p><p><strong>New implementations</strong></p><p>Optional. The fallback return value is <code>Union{}</code>. Ordinarily, at most one of the following should be overloaded for given algorithm <code>LearnAPI.transform_scitype</code>, <code>LearnAPI.transform_type</code>, <code>LearnAPI.transform_observation_scitype</code>, <code>LearnAPI.transform_observation_type</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/50e786d122cb1b0ddefc64f71d77e468c44e03de/src/traits.jl#L638-L670">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LearnAPI.predict_or_transform_mutates" href="#LearnAPI.predict_or_transform_mutates"><code>LearnAPI.predict_or_transform_mutates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.predict_or_transform_mutates(algorithm)</code></pre><p>Returns <code>true</code> if <a href="../predict_transform/#LearnAPI.predict"><code>predict</code></a> or <a href="../predict_transform/#LearnAPI.transform"><code>transform</code></a> possibly mutate their first argument, <code>model</code>, when <code>LearnAPI.algorithm(model) == algorithm</code>. If <code>false</code>, no arguments are ever mutated.</p><p><strong>New implementations</strong></p><p>This trait, falling back to <code>false</code>, may only be overloaded when <code>fit</code> has no data arguments (<code>algorithm</code> does not generalize to new data). See more at <a href="../fit/#LearnAPI.fit"><code>fit</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/50e786d122cb1b0ddefc64f71d77e468c44e03de/src/traits.jl#L305-L317">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LearnAPI.transform_output_scitype" href="#LearnAPI.transform_output_scitype"><code>LearnAPI.transform_output_scitype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.transform_output_scitype(algorithm)</code></pre><p>Return an upper bound on the scitype of the output of the <code>transform</code> operation.</p><p>See also <a href="#LearnAPI.transform_input_scitype"><code>LearnAPI.transform_input_scitype</code></a>.</p><p><strong>New implementations</strong></p><p>Implementation is optional. The fallback return value is <code>Any</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/50e786d122cb1b0ddefc64f71d77e468c44e03de/src/traits.jl#L641-L652">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LearnAPI.transform_output_type" href="#LearnAPI.transform_output_type"><code>LearnAPI.transform_output_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.transform_output_type(algorithm)</code></pre><p>Return an upper bound on the type of the output of the <code>transform</code> operation.</p><p><strong>New implementations</strong></p><p>Implementation is optional. The fallback return value is <code>Any</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/50e786d122cb1b0ddefc64f71d77e468c44e03de/src/traits.jl#L644-L653">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../accessor_functions/">« Accessor Functions</a><a class="docs-footer-nextpage" href="../common_implementation_patterns/">Common Implementation Patterns »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Tuesday 28 November 2023 09:48">Tuesday 28 November 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
