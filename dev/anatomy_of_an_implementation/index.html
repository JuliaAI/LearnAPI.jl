<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Anatomy of an Implementation · LearnAPI.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LearnAPI.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Anatomy of an Implementation</a><ul class="internal"><li><a class="tocitem" href="#Defining-a-model-type"><span>Defining a model type</span></a></li><li><a class="tocitem" href="#A-method-to-fit-the-model"><span>A method to fit the model</span></a></li><li><a class="tocitem" href="#Operations"><span>Operations</span></a></li><li><a class="tocitem" href="#Accessor-functions"><span>Accessor functions</span></a></li><li><a class="tocitem" href="#traits"><span>Model traits</span></a></li><li><a class="tocitem" href="#Training-data-types"><span>Training data types</span></a></li><li><a class="tocitem" href="#Types-for-data-returned-by-operations"><span>Types for data returned by operations</span></a></li><li><a class="tocitem" href="#workflow"><span>Illustrative fit/predict workflow</span></a></li></ul></li><li><a class="tocitem" href="../common_implementation_patterns/">Common Implementation Patterns</a></li><li><a class="tocitem" href="../reference/">Reference</a></li><li><a class="tocitem" href="../fit_update_and_ingest/">Fit, update and ingest</a></li><li><a class="tocitem" href="../operations/">Predict and other operations</a></li><li><a class="tocitem" href="../model_traits/">Model Traits</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Anatomy of an Implementation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Anatomy of an Implementation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaAI/LearnAPI.jl/blob/dev/docs/src/anatomy_of_an_implementation.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Anatomy-of-an-Implementation"><a class="docs-heading-anchor" href="#Anatomy-of-an-Implementation">Anatomy of an Implementation</a><a id="Anatomy-of-an-Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Anatomy-of-an-Implementation" title="Permalink"></a></h1><blockquote><p><strong>Summary.</strong> A <strong>model</strong> is just a container for hyper-parameters. A basic implementation of the ridge regressor requires implementing <code>fit</code> and <code>predict</code> methods dispatched on the model type; <code>predict</code> is an example of an <strong>operation</strong> (another is <code>transform</code>). In this example we also implement an <strong>accessor function</strong> called <code>feature_importance</code> (returning the absolute values of the linear coefficients). The ridge regressor has a target variable and one trait declaration flags the output of <code>predict</code> as being a <a href="../#scope">proxy</a> for the target. Other traits articulate the model&#39;s training data type requirements and the output type of <code>predict</code>.</p></blockquote><p>We begin by describing an implementation of LearnAPI.jl for basic ridge regression (no intercept) to introduce the main actors in any implementation.</p><h2 id="Defining-a-model-type"><a class="docs-heading-anchor" href="#Defining-a-model-type">Defining a model type</a><a id="Defining-a-model-type-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-a-model-type" title="Permalink"></a></h2><p>The first line below imports the lightweight package LearnAPI.jl whose methods we will be extending, the second, libraries needed for the core algorithm.</p><pre><code class="language-julia hljs">using LearnAPI
using LinearAlgebra, Tables</code></pre><p>Next, we define a struct to store the single hyper-parameter <code>lambda</code> of this model:</p><pre><code class="language-julia hljs">struct MyRidge &lt;: LearnAPI.Model
        lambda::Float64
end</code></pre><p>The subtyping <code>MyRidge &lt;: LearnAPI.Model</code> is optional but recommended where it is not otherwise disruptive. If you omit the subtyping then you must declare</p><pre><code class="language-julia hljs">LearnAPI.ismodel(::MyRidge) = true</code></pre><p>as a promise that instances of <code>MyRidge</code> implement LearnAPI.jl.</p><p>Instances of <code>MyRidge</code> are called <strong>models</strong> and <code>MyRidge</code> is a <strong>model type</strong>.</p><p>A keyword argument constructor providing default hyper-parameters is strongly recommended:</p><pre><code class="language-julia hljs">MyRidge(; lambda=0.1) = MyRidge(lambda)</code></pre><h2 id="A-method-to-fit-the-model"><a class="docs-heading-anchor" href="#A-method-to-fit-the-model">A method to fit the model</a><a id="A-method-to-fit-the-model-1"></a><a class="docs-heading-anchor-permalink" href="#A-method-to-fit-the-model" title="Permalink"></a></h2><p>A ridge regressor requires two types of data for training: <strong>input features</strong> <code>X</code> and a <a href="../#scope"><strong>target</strong></a> <code>y</code>. Training is implemented by overloading <code>fit</code>. Here <code>verbosity</code> is an integer (<code>0</code> should train silently, unless warnings are needed):</p><pre><code class="language-julia hljs">function LearnAPI.fit(model::MyRidge, verbosity, X, y)

        # process input:
        x = Tables.matrix(X)  # convert table to matrix
        features = Tables.columnnames(X)

        # core solver:
        coefficients = (x&#39;x + model.lambda*I)\(x&#39;y)

        # prepare output - learned parameters:
        fitted_params = (; coefficients)

        # prepare output - model state:
        state = nothing  # not relevant here

        # prepare output - byproducts of training:
        feature_importances =
                [features[j] =&gt; abs(coefficients[j]) for j in eachindex(features)]
        sort!(feature_importances, by=last) |&gt; reverse!
        verbosity &gt; 1 &amp;&amp; @info &quot;Features in order of importance: $(first.(feature_importances))&quot;
        report = (; feature_importances)

        return fitted_params, state, report
end</code></pre><p>Regarding the return value of <code>fit</code>:</p><ul><li><p>The <code>fitted_params</code> variable is for the model&#39;s learned parameters, for passing to <code>predict</code> (see below).</p></li><li><p>The <code>state</code> variable is only relevant when additionally implementing a <a href="../fit_update_and_ingest/#LearnAPI.update!"><code>LearnAPI.update!</code></a> or <a href="../fit_update_and_ingest/#LearnAPI.ingest!"><code>LearnAPI.ingest!</code></a> method (see <a href="../fit_update_and_ingest/#Fit,-update!-and-ingest!">Fit, update! and ingest!</a>).</p></li><li><p>The <code>report</code> is for other byproducts of training, excluding the learned parameters.</p></li></ul><p>Notice that we have chosen here to suppose that <code>X</code> is presented as a table (rows are the observations); and we suppose <code>y</code> is a <code>Real</code> vector. This is not a restriction on types placed by LearnAPI.jl. However, we can articulate our model&#39;s particular type requirements with the <a href="@ref"><code>LearnAPI.fit_data_scitype</code></a> trait; see <a href="#Training-data-types">Training data types</a> below.</p><h2 id="Operations"><a class="docs-heading-anchor" href="#Operations">Operations</a><a id="Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Operations" title="Permalink"></a></h2><p>Now we need a method for predicting the target on new input features:</p><pre><code class="language-julia hljs">function LearnAPI.predict(::MyRidge, fitted_params, Xnew)
    Xmatrix = Tables.matrix(Xnew)
    report = nothing
    return Xmatrix*fitted_params.coefficients, report
end</code></pre><p>In some models <code>predict</code> computes something of interest in addition to the target prediction, and this <code>report</code> item is returned as the second component of the return value. When there&#39;s nothing to report, we must return <code>nothing</code>, as here.</p><p>Our <code>predict</code> method is an example of an <strong>operation</strong>. Other operations include <code>transform</code> and <code>inverse_transform</code> and a model can implement more than one. For example, a K-means clustering model might implement a <code>transform</code> for dimension reduction, and a <code>predict</code> to return cluster labels.</p><h2 id="Accessor-functions"><a class="docs-heading-anchor" href="#Accessor-functions">Accessor functions</a><a id="Accessor-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Accessor-functions" title="Permalink"></a></h2><p>The arguments of an operation are always <code>(model, fitted_params, data...)</code>. The interface also provides <strong>accessor functions</strong> for extracting information, from the <code>fitted_params</code> and/or <code>report</code>, that is shared by several model types.  There is one for feature importances that we can implement for <code>MyRidge</code>:</p><pre><code class="language-julia hljs">LearnAPI.feature_importances(::MyRidge, fitted_params, report) =
report.feature_importances</code></pre><p>Another example of an accessor function is <code>training_losses</code>.</p><h2 id="traits"><a class="docs-heading-anchor" href="#traits">Model traits</a><a id="traits-1"></a><a class="docs-heading-anchor-permalink" href="#traits" title="Permalink"></a></h2><p>Our model has a target variable, in the sense outlined in <a href="../#scope">Scope and undefined notions</a>, and <code>predict</code> returns an object with exactly the same form as the target. We indicate this behaviour by declaring</p><pre><code class="language-julia hljs">LearnAPI.target_proxy_kind(::Type{&lt;:MyRidge}) = (; predict=LearnAPI.TrueTarget())</code></pre><p>Or, you can use the shorthand</p><pre><code class="language-julia hljs">@trait MyRidge target_proxy_kind = (; predict=LearnAPI.TrueTarget())</code></pre><p>More generally, <code>predict</code> only returns a <em>proxy</em> for the target, such as probability distributions, and we would make a different declaration here. See <a href="../operations/#Target-proxies">Target proxies</a> for details.</p><p><code>LearnAPI.target_proxy_kind</code> is an example of a <strong>model trait</strong>. A complete list of traits and the contracts they imply is given in <a href="../model_traits/#Model-Traits">Model Traits</a>.</p><blockquote><p><strong>MLJ only.</strong> The values of all traits constitute a model&#39;s <strong>metadata</strong>, which is recorded in the searchable MLJ Model Registry, assuming the implementation-providing package is registered there.</p></blockquote><p>We also need to indicate that the target appears in training (this is a <em>supervised</em> model) and the position of <code>target</code> within the <code>data</code> argument of <code>fit</code>:</p><pre><code class="language-julia hljs">@trait MyRidge position_of_target = 2</code></pre><p>As explained in the introduction, LearnAPI.jl does not attempt to define strict model &quot;types&quot;, such as &quot;regressor&quot; or &quot;clusterer&quot;. However, we can optionally specify suggestive keywords, as in</p><pre><code class="language-julia hljs">@trait MyRidge keywords = (:regression,)</code></pre><p>but note that this declaration promises nothing. Do <code>LearnAPI.keywords()</code> to get a list of available keywords.</p><p>Finally, we are required to declare what methods (excluding traits) we have explicitly overloaded for our type:</p><pre><code class="language-julia hljs">@trait MyRidge implemented_methods = (
        :fit,
        :predict,
        :feature_importances,
)</code></pre><h2 id="Training-data-types"><a class="docs-heading-anchor" href="#Training-data-types">Training data types</a><a id="Training-data-types-1"></a><a class="docs-heading-anchor-permalink" href="#Training-data-types" title="Permalink"></a></h2><p>Optional trait declarations articulate the permitted types for training data. To be precise, an implementation makes <a href="https://github.com/JuliaAI/ScientificTypes.jl">scientific type</a> declarations, which in this case look like:</p><pre><code class="language-julia hljs">using ScientificTypesBase
@trait MyRidge fit_data_scitype = Tuple{Table(Continuous), AbstractVector{Continuous}}</code></pre><p>This is a contract that <code>data</code> is acceptable in the call <code>fit(model, verbosity, data...)</code> whenever</p><pre><code class="language-julia hljs">scitype(data) &lt;: Tuple{Table(Continuous), AbstractVector{Continuous}}</code></pre><p>Or, in other words:</p><ul><li><p><code>X</code> in <code>fit(model, verbosity, X, y)</code> is acceptable, provided <code>scitype(X) &lt;: Table(Continuous)</code> - meaning that <code>X</code> is a Tables.jl compatible table whose columns have some <code>&lt;:AbstractFloat</code> element type.</p></li><li><p><code>y</code> in <code>fit(model, verbosity, X, y)</code> is acceptable if <code>scitype(y) &lt;: AbstractVector{Continuous}</code> - meaning that it is an abstract vector with <code>&lt;:AbstractFloat</code> elements.</p></li></ul><h2 id="Types-for-data-returned-by-operations"><a class="docs-heading-anchor" href="#Types-for-data-returned-by-operations">Types for data returned by operations</a><a id="Types-for-data-returned-by-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Types-for-data-returned-by-operations" title="Permalink"></a></h2><p>A promise that an operation, such as <code>predict</code>, returns an object of given scientific type is articulated in this way:</p><pre><code class="language-julia hljs">@trait return_scitypes = (:predict =&gt; AbstractVector{&lt;:Continuous},)</code></pre><p>If <code>predict</code> had instead returned probability distributions, and these implement the <code>Distributions.pdf</code> interface, then the declaration would be</p><pre><code class="language-julia hljs">@trait return_scitypes = (:predict =&gt; AbstractVector{Density{&lt;:Continuous}},)</code></pre><p>There is also an <code>input_scitypes</code> trait for operations. However, this falls back to the scitype for the first argument of <code>fit</code>, as inferred from <code>fit_data_scitype</code> (see above). So we need not overload it here.</p><h2 id="workflow"><a class="docs-heading-anchor" href="#workflow">Illustrative fit/predict workflow</a><a id="workflow-1"></a><a class="docs-heading-anchor-permalink" href="#workflow" title="Permalink"></a></h2><p>Here&#39;s some toy data for supervised learning:</p><pre><code class="language-julia hljs">using Tables

n = 10          # number of training observations
train = 1:6
test = 7:10

a, b, c = rand(n), rand(n), rand(n)
X = (; a, b, c) |&gt; Tables.rowtable
y = 2a - b + 3c + 0.05*rand(n)</code></pre><p>Instantiate a model with relevant hyperparameters:</p><pre><code class="language-julia hljs">model = MyRidge(lambda=0.5)</code></pre><p>Train the model:</p><pre><code class="language-julia hljs">import LearnAPI: fit, predict, feature_importances

fitted_params, state, fit_report = fit(model, 1, X[train], y[train])</code></pre><p>Inspect the learned paramters and report:</p><pre><code class="language-julia hljs">@info &quot;training outcomes&quot; fitted_params report</code></pre><p>Inspect feature importances:</p><pre><code class="language-julia hljs">feature_importances(model, fitted_params, report)</code></pre><p>Make a prediction using new data:</p><pre><code class="language-julia hljs">yhat, predict_report = predict(model, fitted_params, X[test])</code></pre><p>Compare predictions with ground truth</p><pre><code class="language-julia hljs">deviations = yhat - y[test]
loss = deviations .^2 |&gt; sum
@info &quot;Sum of squares loss&quot; loss</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../common_implementation_patterns/">Common Implementation Patterns »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Tuesday 27 September 2022 01:28">Tuesday 27 September 2022</span>. Using Julia version 1.8.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
