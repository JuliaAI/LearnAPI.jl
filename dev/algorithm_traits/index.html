<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Algorithm Traits · LearnAPI.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LearnAPI.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../goals_and_approach/">Goals and Approach</a></li><li><a class="tocitem" href="../anatomy_of_an_implementation/">Anatomy of an Implementation</a></li><li><a class="tocitem" href="../reference/">Reference</a></li><li><a class="tocitem" href="../fit_update_and_ingest/">Fit, update and ingest</a></li><li><a class="tocitem" href="../operations/">Predict and other operations</a></li><li><a class="tocitem" href="../accessor_functions/">Accessor Functions</a></li><li><a class="tocitem" href="../optional_data_interface/">Optional Data Interface</a></li><li class="is-active"><a class="tocitem" href>Algorithm Traits</a><ul class="internal"><li><a class="tocitem" href="#Trait-summary"><span>Trait summary</span></a></li><li><a class="tocitem" href="#Reference"><span>Reference</span></a></li></ul></li><li><a class="tocitem" href="../common_implementation_patterns/">Common Implementation Patterns</a></li><li><a class="tocitem" href="../testing_an_implementation/">Testing an Implementation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Algorithm Traits</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Algorithm Traits</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaAI/LearnAPI.jl/blob/dev/docs/src/algorithm_traits.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Algorithm-Traits"><a class="docs-heading-anchor" href="#Algorithm-Traits">Algorithm Traits</a><a id="Algorithm-Traits-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm-Traits" title="Permalink"></a></h1><blockquote><p><strong>Summary.</strong> Traits allow one to promise particular behaviour for an algorithm, such as: <em>This algorithm supports per-observation weights, which must appear as the third argument of <code>fit</code></em>, or <em>This algorithm&#39;s <code>transform</code> method predicts <code>Real</code> vectors</em>.</p></blockquote><p>Algorithm traits are functions whose first (and usually only) argument is an algorithm. In a new implementation, a single-argument trait is declared following this pattern:</p><pre><code class="language-julia hljs">LearnAPI.is_pure_julia(algorithm::MyAlgorithmType) = true</code></pre><div class="admonition is-category-important"><header class="admonition-header">Important</header><div class="admonition-body"><p>The value of a trait must be the same for all algorithms of the same type,  even if the types differ only in type parameters.  There are exceptions for  some traits, if  <code>is_wrapper(algorithm) = true</code> for all instances <code>algorithm</code> of some type  (composite algorithms).  This requirement occasionally requires that  an existing algorithm implementation be split into 	separate LearnAPI  implementations (e.g., one for regression and another for classification).</p></div></div><p>The declaration above has the shorthand</p><pre><code class="language-julia hljs">@trait MyAlgorithmType is_pure_julia=true</code></pre><p>Multiple traits can be declared like this:</p><pre><code class="language-julia hljs">@trait(
    MyAlgorithmType,
    is_pure_julia = true,
    pkg_name = &quot;MyPackage&quot;,
)</code></pre><h3 id="Special-two-argument-traits"><a class="docs-heading-anchor" href="#Special-two-argument-traits">Special two-argument traits</a><a id="Special-two-argument-traits-1"></a><a class="docs-heading-anchor-permalink" href="#Special-two-argument-traits" title="Permalink"></a></h3><p>The two-argument version of <a href="#LearnAPI.predict_output_scitype"><code>LearnAPI.predict_output_scitype</code></a> and <a href="#LearnAPI.predict_output_scitype"><code>LearnAPI.predict_output_scitype</code></a> are the only overloadable traits with more than one argument. They cannot be declared using the <code>@trait</code> macro.</p><h2 id="Trait-summary"><a class="docs-heading-anchor" href="#Trait-summary">Trait summary</a><a id="Trait-summary-1"></a><a class="docs-heading-anchor-permalink" href="#Trait-summary" title="Permalink"></a></h2><p><strong>Overloadable traits</strong> are available for overloading by any new LearnAPI implementation. <strong>Derived traits</strong> are not, and should not be called by performance critical code</p><h3 id="Overloadable-traits"><a class="docs-heading-anchor" href="#Overloadable-traits">Overloadable traits</a><a id="Overloadable-traits-1"></a><a class="docs-heading-anchor-permalink" href="#Overloadable-traits" title="Permalink"></a></h3><p>In the examples column of the table below, <code>Table</code>, <code>Continuous</code>, <code>Sampleable</code> are names owned by the package <a href="https://github.com/JuliaAI/ScientificTypesBase.jl/">ScientificTypesBase.jl</a>.</p><table><tr><th style="text-align: left">trait</th><th style="text-align: left">fallback value</th><th style="text-align: left">return value</th><th style="text-align: left">example</th></tr><tr><td style="text-align: left"><a href="#LearnAPI.functions"><code>LearnAPI.functions</code></a><code>(algorithm)</code></td><td style="text-align: left"><code>()</code></td><td style="text-align: left">implemented LearnAPI functions (traits excluded)</td><td style="text-align: left"><code>(:fit, :predict)</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.preferred_kind_of_proxy"><code>LearnAPI.preferred_kind_of_proxy</code></a><code>(algorithm)</code></td><td style="text-align: left"><code>LearnAPI.None()</code></td><td style="text-align: left">an instance <code>tp</code> of <code>KindOfProxy</code> for which an implementation of <code>LearnAPI.predict(algorithm, tp, ...)</code> is guaranteed.</td><td style="text-align: left"><code>LearnAPI.Distribution()</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.position_of_target"><code>LearnAPI.position_of_target</code></a><code>(algorithm)</code></td><td style="text-align: left"><code>0</code></td><td style="text-align: left">¹ the positional index of the <strong>target</strong> in <code>data</code> in <code>fit(..., data...; metadata)</code> calls</td><td style="text-align: left">2</td></tr><tr><td style="text-align: left"><a href="#LearnAPI.position_of_weights"><code>LearnAPI.position_of_weights</code></a><code>(algorithm)</code></td><td style="text-align: left"><code>0</code></td><td style="text-align: left">¹ the positional index of <strong>per-observation weights</strong> in <code>data</code> in <code>fit(..., data...; metadata)</code></td><td style="text-align: left">3</td></tr><tr><td style="text-align: left"><a href="#LearnAPI.descriptors"><code>LearnAPI.descriptors</code></a><code>(algorithm)</code></td><td style="text-align: left"><code>()</code></td><td style="text-align: left">lists one or more suggestive algorithm descriptors from <code>LearnAPI.descriptors()</code></td><td style="text-align: left">(:classifier, :probabilistic)</td></tr><tr><td style="text-align: left"><a href="#LearnAPI.is_pure_julia"><code>LearnAPI.is_pure_julia</code></a><code>(algorithm)</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">is <code>true</code> if implementation is 100% Julia code</td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.pkg_name"><code>LearnAPI.pkg_name</code></a><code>(algorithm)</code></td><td style="text-align: left"><code>&quot;unknown&quot;</code></td><td style="text-align: left">name of package providing core code (may be different from package providing LearnAPI.jl implementation)</td><td style="text-align: left"><code>&quot;DecisionTree&quot;</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.pkg_license"><code>LearnAPI.pkg_license</code></a><code>(algorithm)</code></td><td style="text-align: left"><code>&quot;unknown&quot;</code></td><td style="text-align: left">name of license of package providing core code</td><td style="text-align: left"><code>&quot;MIT&quot;</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.doc_url"><code>LearnAPI.doc_url</code></a><code>(algorithm)</code></td><td style="text-align: left"><code>&quot;unknown&quot;</code></td><td style="text-align: left">url providing documentation of the core code</td><td style="text-align: left"><code>&quot;https://en.wikipedia.org/wiki/Decision_tree_learning&quot;</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.load_path"><code>LearnAPI.load_path</code></a><code>(algorithm)</code></td><td style="text-align: left"><code>&quot;unknown&quot;</code></td><td style="text-align: left">a string indicating where the struct for <code>typeof(algorithm)</code> is defined, beginning with name of package providing implementation</td><td style="text-align: left"><code>FastTrees.LearnAPI.DecisionTreeClassifier</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.is_wrapper"><code>LearnAPI.is_wrapper</code></a><code>(algorithm)</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">is <code>true</code> if one or more properties (fields) of <code>algorithm</code> may be an algorithm</td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.human_name"><code>LearnAPI.human_name</code></a><code>(algorithm)</code></td><td style="text-align: left">type name with spaces</td><td style="text-align: left">human name for the algorithm; should be a noun</td><td style="text-align: left">&quot;elastic net regressor&quot;</td></tr><tr><td style="text-align: left"><a href="#LearnAPI.iteration_parameter"><code>LearnAPI.iteration_parameter</code></a><code>(algorithm)</code></td><td style="text-align: left"><code>nothing</code></td><td style="text-align: left">symbolic name of an iteration parameter</td><td style="text-align: left">:epochs</td></tr><tr><td style="text-align: left"><a href="#LearnAPI.fit_keywords"><code>LearnAPI.fit_keywords</code></a><code>(algorithm)</code></td><td style="text-align: left"><code>()</code></td><td style="text-align: left">tuple of symbols for keyword arguments accepted by <code>fit</code> (corresponding  to metadata)</td><td style="text-align: left"><code>(:class_weights,)</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.fit_scitype"><code>LearnAPI.fit_scitype</code></a><code>(algorithm)</code></td><td style="text-align: left"><code>Union{}</code></td><td style="text-align: left">upper bound on <code>scitype(data)</code> in <code>fit(algorithm, verbosity, data...)</code>²</td><td style="text-align: left"><code>Tuple{Table(Continuous), AbstractVector{Continuous}}</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.fit_observation_scitype"><code>LearnAPI.fit_observation_scitype</code></a><code>(algorithm)</code></td><td style="text-align: left"><code>Union{}</code></td><td style="text-align: left">upper bound on <code>scitype(observation)</code> for <code>observation</code> in <code>data</code> and <code>data</code> in <code>fit(algorithm, verbosity, data...)</code>²</td><td style="text-align: left"><code>Tuple{AbstractVector{Continuous}, Continuous}</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.fit_type"><code>LearnAPI.fit_type</code></a><code>(algorithm)</code></td><td style="text-align: left"><code>Union{}</code></td><td style="text-align: left">upper bound on <code>type(data)</code> in <code>fit(algorithm, verbosity, data...)</code>²</td><td style="text-align: left"><code>Tuple{AbstractMatrix{&lt;:Real}, AbstractVector{&lt;:Real}}</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.fit_observation_type"><code>LearnAPI.fit_observation_type</code></a><code>(algorithm)</code></td><td style="text-align: left"><code>Union{}</code></td><td style="text-align: left">upper bound on <code>type(observation)</code> for <code>observation</code> in <code>data</code> and <code>data</code> in <code>fit(algorithm, verbosity, data...)</code>*</td><td style="text-align: left"><code>Tuple{AbstractVector{&lt;:Real}, Real}</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.predict_input_scitype"><code>LearnAPI.predict_input_scitype</code></a><code>(algorithm)</code></td><td style="text-align: left"><code>Union{}</code></td><td style="text-align: left">upper bound on <code>scitype(data)</code> in <code>predict(algorithm, fitted_params, data...)</code>²</td><td style="text-align: left"><code>Table(Continuous)</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.predict_output_scitype"><code>LearnAPI.predict_output_scitype</code></a><code>(algorithm, kind_of_proxy)</code></td><td style="text-align: left"><code>Any</code></td><td style="text-align: left">upper bound on <code>scitype(first(predict(algorithm, kind_of_proxy, ...)))</code></td><td style="text-align: left"><code>AbstractVector{Continuous}</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.predict_input_type"><code>LearnAPI.predict_input_type</code></a><code>(algorithm)</code></td><td style="text-align: left"><code>Union{}</code></td><td style="text-align: left">upper bound on <code>typeof(data)</code> in <code>predict(algorithm, fitted_params, data...)</code>²</td><td style="text-align: left"><code>AbstractMatrix{&lt;:Real}</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.predict_output_type"><code>LearnAPI.predict_output_type</code></a><code>(algorithm, kind_of_proxy)</code></td><td style="text-align: left"><code>Any</code></td><td style="text-align: left">upper bound on <code>typeof(first(predict(algorithm, kind_of_proxy, ...)))</code></td><td style="text-align: left"><code>AbstractVector{&lt;:Real}</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.transform_input_scitype"><code>LearnAPI.transform_input_scitype</code></a><code>(algorithm)</code></td><td style="text-align: left"><code>Union{}</code></td><td style="text-align: left">upper bound on <code>scitype(data)</code> in <code>transform(algorithm, fitted_params, data...)</code>²</td><td style="text-align: left"><code>Table(Continuous)</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.transform_output_scitype"><code>LearnAPI.transform_output_scitype</code></a><code>(algorithm)</code></td><td style="text-align: left"><code>Any</code></td><td style="text-align: left">upper bound on <code>scitype(first(transform(algorithm, ...)))</code></td><td style="text-align: left"><code>Table(Continuous)</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.transform_input_type"><code>LearnAPI.transform_input_type</code></a><code>(algorithm)</code></td><td style="text-align: left"><code>Union{}</code></td><td style="text-align: left">upper bound on <code>typeof(data)</code> in <code>transform(algorithm, fitted_params, data...)</code>²</td><td style="text-align: left"><code>AbstractMatrix{&lt;:Real}}</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.transform_output_type"><code>LearnAPI.transform_output_type</code></a><code>(algorithm)</code></td><td style="text-align: left"><code>Any</code></td><td style="text-align: left">upper bound on <code>typeof(first(transform(algorithm, ...)))</code></td><td style="text-align: left"><code>AbstractMatrix{&lt;:Real}</code></td></tr></table><p>¹ If the value is <code>0</code>, then the variable in boldface type is not supported and not expected to appear in <code>data</code>. If <code>length(data)</code> is less than the trait value, then <code>data</code> is understood to exclude the variable, but note that <code>fit</code> can have multiple signatures of varying lengths, as in <code>fit(algorithm, verbosity, X, y)</code> and <code>fit(algorithm, verbosity, X, y, w)</code>. A non-zero value is a promise that <code>fit</code> includes a signature of sufficient length to include the variable.</p><p>² Assuming no <a href="../optional_data_interface/#data_interface">optional data interface</a> is implemented. See docstring for the general case.</p><h3 id="Derived-Traits"><a class="docs-heading-anchor" href="#Derived-Traits">Derived Traits</a><a id="Derived-Traits-1"></a><a class="docs-heading-anchor-permalink" href="#Derived-Traits" title="Permalink"></a></h3><p>The following convenience methods are provided but intended for overloading:</p><table><tr><th style="text-align: left">trait</th><th style="text-align: left">return value</th><th style="text-align: left">example</th></tr><tr><td style="text-align: left"><code>LearnAPI.name(algorithm)</code></td><td style="text-align: left">algorithm type name as string</td><td style="text-align: left">&quot;PCA&quot;</td></tr><tr><td style="text-align: left"><code>LearnAPI.is_algorithm(algorithm)</code></td><td style="text-align: left"><code>true</code> if <code>functions(algorithm)</code> is not empty</td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.predict_output_scitype"><code>LearnAPI.predict_output_scitype</code></a>(algorithm)</td><td style="text-align: left">dictionary of upper bounds on the scitype of predictions, keyed on subtypes of <a href="../operations/#LearnAPI.KindOfProxy"><code>LearnAPI.KindOfProxy</code></a></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.predict_output_type"><code>LearnAPI.predict_output_type</code></a>(algorithm)</td><td style="text-align: left">dictionary of upper bounds on the type of predictions, keyed on subtypes of <a href="../operations/#LearnAPI.KindOfProxy"><code>LearnAPI.KindOfProxy</code></a></td><td style="text-align: left"></td></tr></table><h2 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.functions" href="#LearnAPI.functions"><code>LearnAPI.functions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.functions(algorithm)</code></pre><p>Return a tuple of symbols, such as <code>(:fit, :predict)</code>, corresponding to LearnAPI methods specifically implemented for objects having the same type as <code>algorithm</code>.  If non-empty, this also guarantees <code>algorithm</code> is an algorithm, in the LearnAPI sense. See the Reference section of the manual for details.</p><p><strong>New implementations</strong></p><p>Every LearnAPI method that is not a trait and which is specifically implemented for <code>typeof(algorithm)</code> must be included in the return value of this trait. Specifically, the return value is a tuple of symbols from this list: <code>:fit</code>, <code>:update!</code>, <code>:ingest!</code>, <code>:predict</code>, <code>:transform</code>, <code>:inverse_transform</code>, <code>:features_importances</code>, <code>:training_labels</code>, <code>:training_losses</code>, <code>:training_scores</code>. To regenerate this list, do <code>LearnAPI.functions()</code>.</p><p>See also <a href="../reference/#LearnAPI.Algorithm"><code>LearnAPI.Algorithm</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/bd5de3b0e9232b081605ab45e70012905450e088/src/algorithm_traits.jl#LL51-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.preferred_kind_of_proxy" href="#LearnAPI.preferred_kind_of_proxy"><code>LearnAPI.preferred_kind_of_proxy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.preferred_kind_of_proxy(algorithm)</code></pre><p>Returns an instance of <a href="../operations/#LearnAPI.KindOfProxy"><code>LearnAPI.KindOfProxy</code></a>, unless <code>LearnAPI.predict</code> is not implemented for objects of type <code>typeof(algorithm)</code>, in which case it returns <code>nothing</code>.</p><p>The returned target proxy is generally the one with the smallest computational cost, if more than one type is supported.</p><p>See also <a href="../operations/#LearnAPI.predict"><code>LearnAPI.predict</code></a>, <a href="../operations/#LearnAPI.KindOfProxy"><code>LearnAPI.KindOfProxy</code></a>.</p><p><strong>New implementations</strong></p><p>Any algorithm implementing <code>LearnAPI.predict</code> must overload this trait.</p><p>The trait must return a lone instance <code>T()</code> for some concrete subtype <code>T &lt;: LearnAPI.KindOfProxy</code>. List these with <code>subtypes(LearnAPI.KindOfProxy)</code> and <code>subtypes(LearnAPI.IID)</code>.</p><p>Suppose, for example, we have the following implementation of a supervised learner returning only probablistic predictions:</p><pre><code class="language-julia hljs">LearnAPI.predict(algorithm::MyNewAlgorithmType, LearnAPI.Distribution(), Xnew) = ...</code></pre><p>Then we can declare</p><pre><code class="language-julia hljs">@trait MyNewAlgorithmType  preferred_kind_of_proxy = LearnAPI.LiteralTarget()</code></pre><p>which is shorthand for</p><pre><code class="language-julia hljs">LearnAPI.preferred_kind_of_proxy(::MyNewAlgorithmType) = LearnAPI.Distribution()</code></pre><p>For more on target variables and target proxies, refer to the LearnAPI documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/bd5de3b0e9232b081605ab45e70012905450e088/src/algorithm_traits.jl#LL72-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.position_of_target" href="#LearnAPI.position_of_target"><code>LearnAPI.position_of_target</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.position_of_target(algorithm)</code></pre><p>Return the expected position of the target variable within <code>data</code> in calls of the form <a href="../fit_update_and_ingest/#LearnAPI.fit"><code>LearnAPI.fit</code></a><code>(algorithm, verbosity, data...)</code>.</p><p>If this number is <code>0</code>, then no target is expected. If this number exceeds <code>length(data)</code>, then <code>data</code> is understood to exclude the target variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/bd5de3b0e9232b081605ab45e70012905450e088/src/algorithm_traits.jl#LL115-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.position_of_weights" href="#LearnAPI.position_of_weights"><code>LearnAPI.position_of_weights</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.position_of_weights(algorithm)</code></pre><p>Return the expected position of per-observation weights within <code>data</code> in calls of the form <a href="../fit_update_and_ingest/#LearnAPI.fit"><code>LearnAPI.fit</code></a><code>(algorithm, verbosity, data...)</code>.</p><p>If this number is <code>0</code>, then no weights are expected. If this number exceeds <code>length(data)</code>, then <code>data</code> is understood to exclude weights, which are assumed to be uniform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/bd5de3b0e9232b081605ab45e70012905450e088/src/algorithm_traits.jl#LL127-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.descriptors" href="#LearnAPI.descriptors"><code>LearnAPI.descriptors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.descriptors(algorithm)</code></pre><p>Lists one or more suggestive algorithm descriptors from this list: <code>:regression</code>, <code>:classification</code>, <code>:clustering</code>, <code>:gradient_descent</code>, <code>:iterative_algorithms</code>, <code>:incremental_algorithms</code>, <code>:dimension_reduction</code>, <code>:encoders</code>, <code>:static_algorithms</code>, <code>:missing_value_imputation</code>, <code>:ensemble_algorithms</code>, <code>:wrappers</code>, <code>:time_series_forecasting</code>, <code>:time_series_classification</code>, <code>:survival_analysis</code>, <code>:distribution_fitters</code>, <code>:Bayesian_algorithms</code>, <code>:outlier_detection</code>, <code>:collaborative_filtering</code>, <code>:text_analysis</code>, <code>:audio_analysis</code>, <code>:natural_language_processing</code>, <code>:image_processing</code> (do <code>LearnAPI.descriptors()</code> to reproduce).</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The value of this trait guarantees no particular behavior. The trait is intended for informal classification purposes only.</p></div></div><p><strong>New implementations</strong></p><p>This trait should return a tuple of symbols, as in <code>(:classifier, :probabilistic)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/bd5de3b0e9232b081605ab45e70012905450e088/src/algorithm_traits.jl#LL168-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.is_pure_julia" href="#LearnAPI.is_pure_julia"><code>LearnAPI.is_pure_julia</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.is_pure_julia(algorithm)</code></pre><p>Returns <code>true</code> if training <code>algorithm</code> requires evaluation of pure Julia code only.</p><p><strong>New implementations</strong></p><p>The fallback is <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/bd5de3b0e9232b081605ab45e70012905450e088/src/algorithm_traits.jl#LL185-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.pkg_name" href="#LearnAPI.pkg_name"><code>LearnAPI.pkg_name</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.pkg_name(algorithm)</code></pre><p>Return the name of the package module which supplies the core training algorithm for <code>algorithm</code>.  This is not necessarily the package providing the LearnAPI interface.</p><p>Returns <code>&quot;unknown&quot;</code> if the algorithm implementation has failed to overload the trait. </p><p><strong>New implementations</strong></p><p>Must return a string, as in <code>&quot;DecisionTree&quot;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/bd5de3b0e9232b081605ab45e70012905450e088/src/algorithm_traits.jl#LL197-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.pkg_license" href="#LearnAPI.pkg_license"><code>LearnAPI.pkg_license</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.pkg_license(algorithm)</code></pre><p>Return the name of the software license, such as <code>&quot;MIT&quot;</code>, applying to the package where the core algorithm for <code>algorithm</code> is implemented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/bd5de3b0e9232b081605ab45e70012905450e088/src/algorithm_traits.jl#LL213-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.doc_url" href="#LearnAPI.doc_url"><code>LearnAPI.doc_url</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.doc_url(algorithm)</code></pre><p>Return a url where the core algorithm for <code>algorithm</code> is documented.</p><p>Returns <code>&quot;unknown&quot;</code> if the algorithm implementation has failed to overload the trait. </p><p><strong>New implementations</strong></p><p>Must return a string, such as <code>&quot;https://en.wikipedia.org/wiki/Decision_tree_learning&quot;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/bd5de3b0e9232b081605ab45e70012905450e088/src/algorithm_traits.jl#LL222-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.load_path" href="#LearnAPI.load_path"><code>LearnAPI.load_path</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.load_path(algorithm)</code></pre><p>Return a string indicating where the <code>struct</code> for <code>typeof(algorithm)</code> can be found, beginning with the name of the package module defining it. For example, a return value of <code>&quot;FastTrees.LearnAPI.DecisionTreeClassifier&quot;</code> means the following julia code will return the algorithm type:</p><pre><code class="language-julia hljs">import FastTrees
FastTrees.LearnAPI.DecisionTreeClassifier</code></pre><p>Returns <code>&quot;unknown&quot;</code> if the algorithm implementation has failed to overload the trait. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/bd5de3b0e9232b081605ab45e70012905450e088/src/algorithm_traits.jl#LL236-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.is_wrapper" href="#LearnAPI.is_wrapper"><code>LearnAPI.is_wrapper</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.is_wrapper(algorithm)</code></pre><p>Returns <code>true</code> if one or more properties (fields) of <code>algorithm</code> may themselves be algorithms, and <code>false</code> otherwise.</p><p><strong>New implementations</strong></p><p>This trait must be overloaded if one or more properties (fields) of <code>algorithm</code> may take algorithm values. Fallback return value is <code>false</code>.</p><p>The value of the trait must depend only on the type of <code>algorithm</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/bd5de3b0e9232b081605ab45e70012905450e088/src/algorithm_traits.jl#LL256-L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.fit_keywords" href="#LearnAPI.fit_keywords"><code>LearnAPI.fit_keywords</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.fit_keywords(algorithm)</code></pre><p>Return a list of keywords that can be provided to <code>fit</code> that correspond to metadata; <code>metadata</code> is for extra information pertaining to the data that is never iterated or subsampled. Examples, include target <em>class</em> weights and group lasso feature groupings. Further examples include feature names, and the pool of target classes, when these are not embedded in the data representation. </p><p><strong>New implementations</strong></p><p>If <code>LearnAPI.fit(algorithm, ...)</code> supports keyword arguments, then this trait must be overloaded, and otherwise not. Fallback returns <code>()</code>.</p><p>Here&#39;s a sample implementation for a classifier that implements a <code>LearnAPI.fit</code> method with signature <code>fit(algorithm::MyClassifier, verbosity, X, y; class_weights=nothing)</code>:</p><pre><code class="nohighlight hljs">LearnAPI.fit_keywords(::Any{&lt;:MyClassifier}) = (:class_weights,)</code></pre><p>or the shorthand</p><pre><code class="nohighlight hljs">@trait MyClassifier fit_keywords=(:class_weights,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/bd5de3b0e9232b081605ab45e70012905450e088/src/algorithm_traits.jl#LL302-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.human_name" href="#LearnAPI.human_name"><code>LearnAPI.human_name</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.human_name(algorithm)</code></pre><p>A human-readable string representation of <code>typeof(algorithm)</code>. Primarily intended for auto-generation of documentation.</p><p><strong>New implementations</strong></p><p>Optional. A fallback takes the type name, inserts spaces and removes capitalization. For example, <code>KNNRegressor</code> becomes <code>&quot;knn regressor&quot;</code>. Better would be to overload the trait to return <code>&quot;K-nearest neighbors regressor&quot;</code>. Ideally, this is a &quot;concrete&quot; noun like <code>&quot;ridge regressor&quot;</code> rather than an &quot;abstract&quot; noun like <code>&quot;ridge regression&quot;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/bd5de3b0e9232b081605ab45e70012905450e088/src/algorithm_traits.jl#LL273-L286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.iteration_parameter" href="#LearnAPI.iteration_parameter"><code>LearnAPI.iteration_parameter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.iteration_parameter(algorithm)</code></pre><p>The name of the iteration parameter of <code>algorithm</code>, or <code>nothing</code> if the algorithm is not iterative.</p><p><strong>New implementations</strong></p><p>Implement if algorithm is iterative. Returns a symbol or <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/bd5de3b0e9232b081605ab45e70012905450e088/src/algorithm_traits.jl#LL289-L299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.fit_scitype" href="#LearnAPI.fit_scitype"><code>LearnAPI.fit_scitype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.fit_scitype(algorithm)</code></pre><p>Return an upper bound on the scitype of data guaranteeing it to work when training <code>algorithm</code>.</p><p>Specifically, if the return value is <code>S</code> and <code>ScientificTypes.scitype(data) &lt;: S</code>, then the following low-level calls are allowed (assuming <code>metadata</code> is also valid and <code>verbosity</code> is an integer):</p><pre><code class="language-julia hljs"># apply data front-end:
data2, metadata2 = LearnAPI.reformat(algorithm, LearnAPI.fit, data...; metadata...)

# train:
LearnAPI.fit(algorithm, verbosity, data2...; metadata2...)</code></pre><p>See also <a href="#LearnAPI.fit_type"><code>LearnAPI.fit_type</code></a>, <a href="#LearnAPI.fit_observation_scitype"><code>LearnAPI.fit_observation_scitype</code></a>, <a href="#LearnAPI.fit_observation_type"><code>LearnAPI.fit_observation_type</code></a>.</p><p><strong>New implementations</strong></p><p>Optional. The fallback return value is <code>Union{}</code>.  No more than one of the following should be overloaded for an algorithm type: <code>LearnAPI.fit_scitype</code>, <code>LearnAPI.fit_type</code>, <code>LearnAPI.fit_observation_scitype</code>, <code>LearnAPI.fit_observation_type</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/bd5de3b0e9232b081605ab45e70012905450e088/src/algorithm_traits.jl#LL330-L355">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.fit_type" href="#LearnAPI.fit_type"><code>LearnAPI.fit_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.fit_type(algorithm)</code></pre><p>Return an upper bound on the type of data guaranteeing it to work when training <code>algorithm</code>.</p><p>Specifically, if the return value is <code>T</code> and <code>typeof(data) &lt;: T</code>, then the following low-level calls are allowed (assuming <code>metadata</code> is also valid and <code>verbosity</code> is an integer):</p><pre><code class="language-julia hljs"># apply data front-end:
data2, metadata2 = LearnAPI.reformat(algorithm, LearnAPI.fit, data...; metadata...)

# train:
LearnAPI.fit(algorithm, verbosity, data2...; metadata2...)</code></pre><p>See also <a href="#LearnAPI.fit_scitype"><code>LearnAPI.fit_scitype</code></a>, <a href="#LearnAPI.fit_observation_type"><code>LearnAPI.fit_observation_type</code></a>. <a href="#LearnAPI.fit_observation_scitype"><code>LearnAPI.fit_observation_scitype</code></a></p><p><strong>New implementations</strong></p><p>Optional. The fallback return value is <code>Union{}</code>. No more than one of the following should be overloaded for an algorithm type: <code>LearnAPI.fit_scitype</code>, <code>LearnAPI.fit_type</code>, <code>LearnAPI.fit_observation_scitype</code>, <code>LearnAPI.fit_observation_type</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/bd5de3b0e9232b081605ab45e70012905450e088/src/algorithm_traits.jl#LL391-L415">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.fit_observation_scitype" href="#LearnAPI.fit_observation_scitype"><code>LearnAPI.fit_observation_scitype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.fit_observation_scitype(algorithm)</code></pre><p>Return an upper bound on the scitype of observations guaranteed to work when training <code>algorithm</code> (independent of the type/scitype of the data container itself).</p><p>Specifically, denoting the type returned above by <code>S</code>, suppose a user supplies training data, <code>data</code> - typically a tuple, such as <code>(X, y)</code> - and valid metadata, <code>metadata</code>, and one computes</p><pre><code class="nohighlight hljs">data2, metadata2 = LearnAPI.reformat(algorithm, LearnAPI.fit, data...; metadata...)</code></pre><p>Then, assuming</p><pre><code class="nohighlight hljs">ScientificTypes.scitype(LearnAPI.getobs(algorithm, LearnAPI.fit, data2, i)) &lt;: S</code></pre><p>for any valid index <code>i</code>, the following is guaranteed to work:</p><pre><code class="language-julia hljs">LearnAPI.fit(algorithm, verbosity, data2...; metadata2...)</code></pre><p>See also See also <a href="#LearnAPI.fit_type"><code>LearnAPI.fit_type</code></a>, <a href="#LearnAPI.fit_scitype"><code>LearnAPI.fit_scitype</code></a>, <a href="#LearnAPI.fit_observation_type"><code>LearnAPI.fit_observation_type</code></a>.</p><p><strong>New implementations</strong></p><p>Optional. The fallback return value is <code>Union{}</code>. No more than one of the following should be overloaded for an algorithm type: <code>LearnAPI.fit_scitype</code>, <code>LearnAPI.fit_type</code>, <code>LearnAPI.fit_observation_scitype</code>, <code>LearnAPI.fit_observation_type</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/bd5de3b0e9232b081605ab45e70012905450e088/src/algorithm_traits.jl#LL358-L388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.fit_observation_type" href="#LearnAPI.fit_observation_type"><code>LearnAPI.fit_observation_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.fit_observation_type(algorithm)</code></pre><p>Return an upper bound on the type of observations guaranteed to work when training <code>algorithm</code> (independent of the type/scitype of the data container itself).</p><p>Specifically, denoting the type returned above by <code>T</code>, suppose a user supplies training data, <code>data</code> - typically a tuple, such as <code>(X, y)</code> - and valid metadata, <code>metadata</code>, and one computes</p><pre><code class="nohighlight hljs">data2, metadata2 = LearnAPI.reformat(algorithm, LearnAPI.fit, data...; metadata...)</code></pre><p>Then, assuming</p><pre><code class="nohighlight hljs">typeof(LearnAPI.getobs(algorithm, LearnAPI.fit, data2, i)) &lt;: T</code></pre><p>for any valid index <code>i</code>, the following is guaranteed to work:</p><pre><code class="language-julia hljs">LearnAPI.fit(algorithm, verbosity, data2...; metadata2...)</code></pre><p>See also See also <a href="#LearnAPI.fit_type"><code>LearnAPI.fit_type</code></a>, <a href="#LearnAPI.fit_scitype"><code>LearnAPI.fit_scitype</code></a>, <a href="#LearnAPI.fit_observation_scitype"><code>LearnAPI.fit_observation_scitype</code></a>.</p><p><strong>New implementations</strong></p><p>Optional. The fallback return value is <code>Union{}</code>. No more than one of the following should be overloaded for an algorithm type: <code>LearnAPI.fit_scitype</code>, <code>LearnAPI.fit_type</code>, <code>LearnAPI.fit_observation_scitype</code>, <code>LearnAPI.fit_observation_type</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/bd5de3b0e9232b081605ab45e70012905450e088/src/algorithm_traits.jl#LL418-L448">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.predict_input_scitype" href="#LearnAPI.predict_input_scitype"><code>LearnAPI.predict_input_scitype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> LearnAPI.predict_input_scitype(algorithm)</code></pre><p>Return an upper bound on the scitype of input data guaranteed to work with the <code>predict</code>  operation.</p><p>Specifically, if <code>S</code> is the value returned and <code>ScientificTypes.scitype(data) &lt;: S</code>,  then the following low-level calls are allowed</p><pre><code class="nohighlight hljs"> data2 = LearnAPI.reformat(algorithm, LearnAPI.predict, data...)
 LearnAPI.predict(algorithm, fitted_params, data2...)</code></pre><p>Here <code>fitted_params</code> are the learned parameters returned by an appropriate call to  <code>LearnAPI.fit</code>.</p><p>See also <a href="#LearnAPI.predict_input_type"><code>LearnAPI.predict_input_type</code></a>.</p><p><strong>New implementations</strong></p><p>Implementation is optional. The fallback return value is <code>Union{}</code>. Should not be  overloaded if <code>LearnAPI.predict_input_type</code> is overloaded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/bd5de3b0e9232b081605ab45e70012905450e088/src/algorithm_traits.jl#LL545-L567">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.predict_output_scitype" href="#LearnAPI.predict_output_scitype"><code>LearnAPI.predict_output_scitype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.predict_output_scitype(algorithm, kind_of_proxy::KindOfProxy)</code></pre><p>Return an upper bound for the scitypes of predictions of the specified form where supported, and otherwise return <code>Any</code>. For example, if</p><pre><code class="nohighlight hljs">ŷ, report = LearnAPI.predict(algorithm, LearnAPI.Distribution(), data...)</code></pre><p>successfully returns (i.e., <code>algorithm</code> supports predictions of target probability distributions) then the following is guaranteed to hold:</p><pre><code class="nohighlight hljs">scitype(ŷ) &lt;: LearnAPI.predict_output_scitype(algorithm, LearnAPI.Distribution())</code></pre><p><strong>Note.</strong> This trait has a single-argument &quot;convenience&quot; version <code>LearnAPI.predict_output_scitype(algorithm)</code> derived from this one, which returns a dictionary keyed on target proxy types.</p><p>See also <a href="../operations/#LearnAPI.KindOfProxy"><code>LearnAPI.KindOfProxy</code></a>, <a href="../operations/#LearnAPI.predict"><code>LearnAPI.predict</code></a>, <a href="#LearnAPI.predict_input_scitype"><code>LearnAPI.predict_input_scitype</code></a>.</p><p><strong>New implementations</strong></p><p>Overloading the trait is optional. Here&#39;s a sample implementation for a supervised regressor type <code>MyRgs</code> that only predicts actual values of the target:</p><pre><code class="nohighlight hljs">LearnAPI.predict(alogrithm::MyRgs, ::LearnAPI.LiteralTarget, data...) = ...
LearnAPI.predict_output_scitype(::MyRgs, ::LearnAPI.LiteralTarget) =
    AbstractVector{ScientificTypesBase.Continuous}</code></pre><p>The fallback method returns <code>Any</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/bd5de3b0e9232b081605ab45e70012905450e088/src/algorithm_traits.jl#LL601-L632">source</a></section><section><div><pre><code class="nohighlight hljs">LearnAPI.predict_output_scitype(algorithm)</code></pre><p>Return a dictionary of upper bounds on the scitype of predictions, keyed on concrete subtypes of <a href="../operations/#LearnAPI.KindOfProxy"><code>LearnAPI.KindOfProxy</code></a>. Each of these subtypes respresents a different form of target prediction (<code>LiteralTarget</code>, <code>Distribution</code>, <code>SurvivalFunction</code>, etc) possibly supported by <code>algorithm</code>, but the existence of a key does not guarantee that form is supported.</p><p>As an example, if</p><pre><code class="nohighlight hljs">ŷ, report = LearnAPI.predict(algorithm, LearnAPI.Distribution(), data...)</code></pre><p>successfully returns (i.e., <code>algorithm</code> supports predictions of target probability distributions) then the following is guaranteed to hold:</p><pre><code class="nohighlight hljs">scitype(ŷ) &lt;: LearnAPI.predict_output_scitype(algorithm)[LearnAPI.Distribution]</code></pre><p>See also <a href="../operations/#LearnAPI.KindOfProxy"><code>LearnAPI.KindOfProxy</code></a>, <a href="../operations/#LearnAPI.predict"><code>LearnAPI.predict</code></a>, <a href="#LearnAPI.predict_input_scitype"><code>LearnAPI.predict_input_scitype</code></a>.</p><p><strong>New implementations</strong></p><p>This single argument trait should not be overloaded. Instead, overload <a href="#LearnAPI.predict_output_scitype"><code>LearnAPI.predict_output_scitype</code></a>(algorithm, kind<em>of</em>proxy). See above.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/bd5de3b0e9232b081605ab45e70012905450e088/src/algorithm_traits.jl#LL643-L669">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.predict_input_type" href="#LearnAPI.predict_input_type"><code>LearnAPI.predict_input_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.predict_input_type(algorithm)</code></pre><p>Return an upper bound on the type of input data guaranteed to work with the <code>predict</code> operation.</p><p>Specifically, if <code>T</code> is the value returned and <code>typeof(data) &lt;: S</code>, then the following low-level calls are allowed</p><pre><code class="nohighlight hljs">data2 = LearnAPI.reformat(algorithm, LearnAPI.predict, data...)
LearnAPI.predict(algorithm, fitted_params, data2...)</code></pre><p>Here <code>fitted_params</code> are the learned parameters returned by an appropriate call to <code>LearnAPI.fit</code>.</p><p>See also <a href="#LearnAPI.predict_input_scitype"><code>LearnAPI.predict_input_scitype</code></a>.</p><p><strong>New implementations</strong></p><p>Implementation is optional. The fallback return value is <code>Union{}</code>. Should not be overloaded if <code>LearnAPI.predict_input_scitype</code> is overloaded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/bd5de3b0e9232b081605ab45e70012905450e088/src/algorithm_traits.jl#LL548-L570">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.predict_output_type" href="#LearnAPI.predict_output_type"><code>LearnAPI.predict_output_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.predict_output_type(algorithm, kind_of_proxy::KindOfProxy)</code></pre><p>Return an upper bound for the types of predictions of the specified form where supported, and otherwise return <code>Any</code>. For example, if</p><pre><code class="nohighlight hljs">ŷ, report = LearnAPI.predict(algorithm, LearnAPI.Distribution(), data...)</code></pre><p>successfully returns (i.e., <code>algorithm</code> supports predictions of target probability distributions) then the following is guaranteed to hold:</p><pre><code class="nohighlight hljs">type(ŷ) &lt;: LearnAPI.predict_output_type(algorithm, LearnAPI.Distribution())</code></pre><p><strong>Note.</strong> This trait has a single-argument &quot;convenience&quot; version <code>LearnAPI.predict_output_type(algorithm)</code> derived from this one, which returns a dictionary keyed on target proxy types.</p><p>See also <a href="../operations/#LearnAPI.KindOfProxy"><code>LearnAPI.KindOfProxy</code></a>, <a href="../operations/#LearnAPI.predict"><code>LearnAPI.predict</code></a>, <a href="#LearnAPI.predict_input_type"><code>LearnAPI.predict_input_type</code></a>.</p><p><strong>New implementations</strong></p><p>Overloading the trait is optional. Here&#39;s a sample implementation for a supervised regressor type <code>MyRgs</code> that only predicts actual values of the target:</p><pre><code class="nohighlight hljs">LearnAPI.predict(alogrithm::MyRgs, ::LearnAPI.LiteralTarget, data...) = ...
LearnAPI.predict_output_type(::MyRgs, ::LearnAPI.LiteralTarget) =
    AbstractVector{ScientificTypesBase.Continuous}</code></pre><p>The fallback method returns <code>Any</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/bd5de3b0e9232b081605ab45e70012905450e088/src/algorithm_traits.jl#LL604-L635">source</a></section><section><div><pre><code class="nohighlight hljs">LearnAPI.predict_output_type(algorithm)</code></pre><p>Return a dictionary of upper bounds on the type of predictions, keyed on concrete subtypes of <a href="../operations/#LearnAPI.KindOfProxy"><code>LearnAPI.KindOfProxy</code></a>. Each of these subtypes respresents a different form of target prediction (<code>LiteralTarget</code>, <code>Distribution</code>, <code>SurvivalFunction</code>, etc) possibly supported by <code>algorithm</code>, but the existence of a key does not guarantee that form is supported.</p><p>As an example, if</p><pre><code class="nohighlight hljs">ŷ, report = LearnAPI.predict(algorithm, LearnAPI.Distribution(), data...)</code></pre><p>successfully returns (i.e., <code>algorithm</code> supports predictions of target probability distributions) then the following is guaranteed to hold:</p><pre><code class="nohighlight hljs">type(ŷ) &lt;: LearnAPI.predict_output_type(algorithm)[LearnAPI.Distribution]</code></pre><p>See also <a href="../operations/#LearnAPI.KindOfProxy"><code>LearnAPI.KindOfProxy</code></a>, <a href="../operations/#LearnAPI.predict"><code>LearnAPI.predict</code></a>, <a href="#LearnAPI.predict_input_type"><code>LearnAPI.predict_input_type</code></a>.</p><p><strong>New implementations</strong></p><p>This single argument trait should not be overloaded. Instead, overload <a href="#LearnAPI.predict_output_type"><code>LearnAPI.predict_output_type</code></a>(algorithm, kind<em>of</em>proxy). See above.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/bd5de3b0e9232b081605ab45e70012905450e088/src/algorithm_traits.jl#LL648-L674">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.transform_input_scitype" href="#LearnAPI.transform_input_scitype"><code>LearnAPI.transform_input_scitype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> LearnAPI.transform_input_scitype(algorithm)</code></pre><p>Return an upper bound on the scitype of input data guaranteed to work with the <code>transform</code>  operation.</p><p>Specifically, if <code>S</code> is the value returned and <code>ScientificTypes.scitype(data) &lt;: S</code>,  then the following low-level calls are allowed</p><pre><code class="nohighlight hljs"> data2 = LearnAPI.reformat(algorithm, LearnAPI.transform, data...)
 LearnAPI.transform(algorithm, fitted_params, data2...)</code></pre><p>Here <code>fitted_params</code> are the learned parameters returned by an appropriate call to  <code>LearnAPI.fit</code>.</p><p>See also <a href="#LearnAPI.transform_input_type"><code>LearnAPI.transform_input_type</code></a>.</p><p><strong>New implementations</strong></p><p>Implementation is optional. The fallback return value is <code>Union{}</code>. Should not be  overloaded if <code>LearnAPI.transform_input_type</code> is overloaded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/bd5de3b0e9232b081605ab45e70012905450e088/src/algorithm_traits.jl#LL551-L573">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.transform_output_scitype" href="#LearnAPI.transform_output_scitype"><code>LearnAPI.transform_output_scitype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.transform_output_scitype(algorithm)</code></pre><p>Return an upper bound on the scitype of the output of the <code>transform</code> operation.</p><p>Specifically, if <code>S</code> is the value returned, and if</p><pre><code class="nohighlight hljs">output, report = LearnAPI.transform(algorithm, fitted_params, data...)</code></pre><p>for suitable <code>fitted_params</code> and <code>data</code>, then</p><pre><code class="nohighlight hljs">ScientificTypes.scitype(output) &lt;: S</code></pre><p>See also <a href="#LearnAPI.transform_input_scitype"><code>LearnAPI.transform_input_scitype</code></a>.</p><p><strong>New implementations</strong></p><p>Implementation is optional. The fallback return value is <code>Any</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/bd5de3b0e9232b081605ab45e70012905450e088/src/algorithm_traits.jl#LL554-L573">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.transform_input_type" href="#LearnAPI.transform_input_type"><code>LearnAPI.transform_input_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.transform_input_type(algorithm)</code></pre><p>Return an upper bound on the type of input data guaranteed to work with the <code>transform</code> operation.</p><p>Specifically, if <code>T</code> is the value returned and <code>typeof(data) &lt;: S</code>, then the following low-level calls are allowed</p><pre><code class="nohighlight hljs">data2 = LearnAPI.reformat(algorithm, LearnAPI.transform, data...)
LearnAPI.transform(algorithm, fitted_params, data2...)</code></pre><p>Here <code>fitted_params</code> are the learned parameters returned by an appropriate call to <code>LearnAPI.fit</code>.</p><p>See also <a href="#LearnAPI.transform_input_scitype"><code>LearnAPI.transform_input_scitype</code></a>.</p><p><strong>New implementations</strong></p><p>Implementation is optional. The fallback return value is <code>Union{}</code>. Should not be overloaded if <code>LearnAPI.transform_input_scitype</code> is overloaded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/bd5de3b0e9232b081605ab45e70012905450e088/src/algorithm_traits.jl#LL557-L579">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.transform_output_type" href="#LearnAPI.transform_output_type"><code>LearnAPI.transform_output_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.transform_output_type(algorithm)</code></pre><p>Return an upper bound on the type of the output of the <code>transform</code> operation.</p><p>Specifically, if <code>T</code> is the value returned, and if</p><pre><code class="nohighlight hljs">output, report = LearnAPI.transform(algorithm, fitted_params, data...)</code></pre><p>for suitable <code>fitted_params</code> and <code>data</code>, then</p><pre><code class="nohighlight hljs">typeof(output) &lt;: T</code></pre><p>See also <a href="#LearnAPI.transform_input_type"><code>LearnAPI.transform_input_type</code></a>.</p><p><strong>New implementations</strong></p><p>Implementation is optional. The fallback return value is <code>Any</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/bd5de3b0e9232b081605ab45e70012905450e088/src/algorithm_traits.jl#LL560-L579">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../optional_data_interface/">« Optional Data Interface</a><a class="docs-footer-nextpage" href="../common_implementation_patterns/">Common Implementation Patterns »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 11 October 2023 03:52">Wednesday 11 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
