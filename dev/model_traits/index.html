<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Model Traits · LearnAPI.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LearnAPI.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../anatomy_of_an_implementation/">Anatomy of an Implementation</a></li><li><a class="tocitem" href="../reference/">Reference</a></li><li><a class="tocitem" href="../fit_update_and_ingest/">Fit, update and ingest</a></li><li><a class="tocitem" href="../operations/">Predict and other operations</a></li><li><a class="tocitem" href="../accessor_functions/">Accessor Functions</a></li><li><a class="tocitem" href="../optional_data_interface/">Optional Data Interface</a></li><li class="is-active"><a class="tocitem" href>Model Traits</a><ul class="internal"><li><a class="tocitem" href="#Ordinary-traits"><span>Ordinary traits</span></a></li><li><a class="tocitem" href="#Derived-Traits"><span>Derived Traits</span></a></li><li><a class="tocitem" href="#Reference"><span>Reference</span></a></li></ul></li><li><a class="tocitem" href="../common_implementation_patterns/">Common Implementation Patterns</a></li><li><a class="tocitem" href="../testing_an_implementation/">Testing an Implementation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Model Traits</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Model Traits</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaAI/LearnAPI.jl/blob/dev/docs/src/model_traits.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Model-Traits"><a class="docs-heading-anchor" href="#Model-Traits">Model Traits</a><a id="Model-Traits-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Traits" title="Permalink"></a></h1><blockquote><p><strong>Summary.</strong> Traits allow one to promise particular behaviour for a model, such as: <em>This model supports per-observation weights, which must appear as the third argument of <code>fit</code></em>, or <em>This model predicts probability distributions for the target</em>, or <em>This model&#39;s <code>transform</code> method predicts <code>Real</code> vectors</em>.</p></blockquote><p>Traits are optional, except where required by the implementation of some LearnAPI method and documented in that method&#39;s docstring. Unless a model has no functionality whatsoever, <a href="#LearnAPI.functions"><code>LearnAPI.functions</code></a><code>(model)</code> will need to be overloaded.</p><p>Traits are often called on instances but are frequently <em>defined</em> on model <em>types</em>, as in</p><pre><code class="language-julia hljs">LearnAPI.is_pure_julia(::Type{&lt;:MyModelType}) = true</code></pre><p>which has the shorthand</p><pre><code class="language-julia hljs">@trait MyModelType is_pure_julia=true</code></pre><p>So, for convenience, every trait <code>t</code> is provided the fallback implementation</p><pre><code class="language-julia hljs">t(model) = t(typeof(model))</code></pre><p>This means <code>LearnAPI.is_pure_julia(model) = true</code> whenever <code>model isa MyModelType</code> in the above example.</p><p>Every trait has a global fallback implementation for <code>::Type</code>. </p><p>Traits that vary from instance to instance of the same type are discouraged, except in the case of composite models (<code>is_wrapper(model) = true</code>) where this is unavoidable. One reason for this is so one can associate with each model type a unique set of trait-based &quot;model metadata&quot; for inclusion in searchable model databases. This requirement occasionally requires that an existing model implementation be split into several separate LearnAPI implementations (e.g., one for regression and another for classification).</p><p>Ordinary traits are available for overloading by an new model implementation. Derived traits are not.</p><h2 id="Ordinary-traits"><a class="docs-heading-anchor" href="#Ordinary-traits">Ordinary traits</a><a id="Ordinary-traits-1"></a><a class="docs-heading-anchor-permalink" href="#Ordinary-traits" title="Permalink"></a></h2><p>In the examples column of the table below, <code>Table</code>, <code>Continuous</code>, <code>Sampleable</code> are names owned by the package <a href="https://github.com/JuliaAI/ScientificTypesBase.jl/">ScientificTypesBase.jl</a>.</p><table><tr><th style="text-align: left">trait</th><th style="text-align: left">fallback value</th><th style="text-align: left">return value</th><th style="text-align: left">example</th></tr><tr><td style="text-align: left"><a href="#LearnAPI.functions"><code>LearnAPI.functions</code></a><code>(model)</code></td><td style="text-align: left"><code>()</code></td><td style="text-align: left">implemented LearnAPI functions (traits excluded)</td><td style="text-align: left"><code>(:fit, :predict)</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.predict_proxy"><code>LearnAPI.predict_proxy</code></a><code>(model)</code></td><td style="text-align: left"><code>LearnAPI.None()</code></td><td style="text-align: left">form of target proxy output by <code>predict</code></td><td style="text-align: left"><code>LearnAPI.Distribution()</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.predict_joint_proxy"><code>LearnAPI.predict_joint_proxy</code></a><code>(model)</code></td><td style="text-align: left"><code>LearnAPI.None()</code></td><td style="text-align: left">form of target proxy output by <code>predict_joint</code></td><td style="text-align: left"><code>LearnAPI.Distribution()</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.position_of_target"><code>LearnAPI.position_of_target</code></a><code>(model)</code></td><td style="text-align: left"><code>0</code></td><td style="text-align: left">† the positional index of the <strong>target</strong> in <code>data</code> in <code>fit(..., data...; metadata)</code> calls</td><td style="text-align: left">2</td></tr><tr><td style="text-align: left"><a href="#LearnAPI.position_of_weights"><code>LearnAPI.position_of_weights</code></a><code>(model)</code></td><td style="text-align: left"><code>0</code></td><td style="text-align: left">† the positional index of <strong>per-observation weights</strong> in <code>data</code> in <code>fit(..., data...; metadata)</code></td><td style="text-align: left">3</td></tr><tr><td style="text-align: left"><a href="#LearnAPI.descriptors"><code>LearnAPI.descriptors</code></a><code>(model)</code></td><td style="text-align: left"><code>()</code></td><td style="text-align: left">lists one or more suggestive model descriptors from <code>LearnAPI.descriptors()</code></td><td style="text-align: left">(:classifier, :probabilistic)</td></tr><tr><td style="text-align: left"><a href="#LearnAPI.is_pure_julia"><code>LearnAPI.is_pure_julia</code></a><code>(model)</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">is <code>true</code> if implementation is 100% Julia code</td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.pkg_name"><code>LearnAPI.pkg_name</code></a><code>(model)</code></td><td style="text-align: left"><code>&quot;unknown&quot;</code></td><td style="text-align: left">name of package providing core algorithm (may be different from package providing LearnAPI.jl implementation)</td><td style="text-align: left"><code>&quot;DecisionTree&quot;</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.pkg_license"><code>LearnAPI.pkg_license</code></a><code>(model)</code></td><td style="text-align: left"><code>&quot;unknown&quot;</code></td><td style="text-align: left">name of license of package providing core algorithm</td><td style="text-align: left"><code>&quot;MIT&quot;</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.doc_url"><code>LearnAPI.doc_url</code></a><code>(model)</code></td><td style="text-align: left"><code>&quot;unknown&quot;</code></td><td style="text-align: left">url providing documentation of the core algorithm</td><td style="text-align: left"><code>&quot;https://en.wikipedia.org/wiki/Decision_tree_learning&quot;</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.load_path"><code>LearnAPI.load_path</code></a><code>(model)</code></td><td style="text-align: left"><code>&quot;unknown&quot;</code></td><td style="text-align: left">a string indicating where the struct for <code>typeof(model)</code> is defined, beginning with name of package providing implementation</td><td style="text-align: left"><code>FastTrees.LearnAPI.DecisionTreeClassifier</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.is_wrapper"><code>LearnAPI.is_wrapper</code></a><code>(model)</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">is <code>true</code> if one or more properties (fields) of <code>model</code> may be a model</td><td style="text-align: left"><code>true</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.human_name"><code>LearnAPI.human_name</code></a><code>(model)</code></td><td style="text-align: left">type name with spaces</td><td style="text-align: left">human name for the model; should be a noun</td><td style="text-align: left">&quot;elastic net regressor&quot;</td></tr><tr><td style="text-align: left"><a href="#LearnAPI.iteration_parameter"><code>LearnAPI.iteration_parameter</code></a><code>(model)</code></td><td style="text-align: left"><code>nothing</code></td><td style="text-align: left">symbolic name of an iteration parameter</td><td style="text-align: left">:epochs</td></tr><tr><td style="text-align: left"><a href="#LearnAPI.fit_keywords"><code>LearnAPI.fit_keywords</code></a><code>(model)</code></td><td style="text-align: left"><code>()</code></td><td style="text-align: left">tuple of symbols for keyword arguments accepted by <code>fit</code> (corresponding  to metadata)</td><td style="text-align: left"><code>(:class_weights,)</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.fit_scitype"><code>LearnAPI.fit_scitype</code></a><code>(model)</code></td><td style="text-align: left"><code>Union{}</code></td><td style="text-align: left">upper bound on <code>scitype(data)</code> in <code>fit(model, verbosity, data...)</code>††</td><td style="text-align: left"><code>Tuple{Table(Continuous), AbstractVector{Continuous}}</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.fit_observation_scitype"><code>LearnAPI.fit_observation_scitype</code></a><code>(model)</code></td><td style="text-align: left"><code>Union{}</code></td><td style="text-align: left">upper bound on <code>scitype(observation)</code> for <code>observation</code> in <code>data</code> and <code>data</code> in <code>fit(model, verbosity, data...)</code>††</td><td style="text-align: left"><code>Tuple{AbstractVector{Continuous}, Continuous}</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.fit_type"><code>LearnAPI.fit_type</code></a><code>(model)</code></td><td style="text-align: left"><code>Union{}</code></td><td style="text-align: left">upper bound on <code>type(data)</code> in <code>fit(model, verbosity, data...)</code>††</td><td style="text-align: left"><code>Tuple{AbstractMatrix{&lt;:Real}, AbstractVector{&lt;:Real}}</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.fit_observation_type"><code>LearnAPI.fit_observation_type</code></a><code>(model)</code></td><td style="text-align: left"><code>Union{}</code></td><td style="text-align: left">upper bound on <code>type(observation)</code> for <code>observation</code> in <code>data</code> and <code>data</code> in <code>fit(model, verbosity, data...)</code>*</td><td style="text-align: left"><code>Tuple{AbstractVector{&lt;:Real}, Real}</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.predict_input_scitype"><code>LearnAPI.predict_input_scitype</code></a><code>(model)</code></td><td style="text-align: left"><code>Union{}</code></td><td style="text-align: left">upper bound on <code>scitype(data)</code> in <code>predict(model, fitted_params, data...)</code>††</td><td style="text-align: left"><code>Table(Continuous)</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.predict_output_scitype"><code>LearnAPI.predict_output_scitype</code></a><code>(model)</code></td><td style="text-align: left"><code>Any</code></td><td style="text-align: left">upper bound on <code>scitype(first(predict(model, ...)))</code></td><td style="text-align: left"><code>AbstractVector{Continuous}</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.predict_input_type"><code>LearnAPI.predict_input_type</code></a><code>(model)</code></td><td style="text-align: left"><code>Union{}</code></td><td style="text-align: left">upper bound on <code>typeof(data)</code> in <code>predict(model, fitted_params, data...)</code>††</td><td style="text-align: left"><code>AbstractMatrix{&lt;:Real}</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.predict_output_type"><code>LearnAPI.predict_output_type</code></a><code>(model)</code></td><td style="text-align: left"><code>Any</code></td><td style="text-align: left">upper bound on <code>typeof(first(predict(model, ...)))</code></td><td style="text-align: left"><code>AbstractVector{&lt;:Real}</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.predict_joint_input_scitype"><code>LearnAPI.predict_joint_input_scitype</code></a><code>(model)</code></td><td style="text-align: left"><code>Union{}</code></td><td style="text-align: left">upper bound on <code>scitype(data)</code> in <code>predict_joint(model, fitted_params, data...)</code>††</td><td style="text-align: left"><code>Table(Continuous)</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.predict_joint_output_scitype"><code>LearnAPI.predict_joint_output_scitype</code></a><code>(model)</code></td><td style="text-align: left"><code>Any</code></td><td style="text-align: left">upper bound on <code>scitype(first(predict_joint(model, ...)))</code></td><td style="text-align: left"><code>Sampleable{&lt;:AbstractVector{Continuous}}</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.predict_joint_input_type"><code>LearnAPI.predict_joint_input_type</code></a><code>(model)</code></td><td style="text-align: left"><code>Union{}</code></td><td style="text-align: left">upper bound on <code>typeof(data)</code> in <code>predict_joint(model, fitted_params, data...)</code>††</td><td style="text-align: left"><code>AbstractMatrix{&lt;:Real}</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.predict_joint_output_type"><code>LearnAPI.predict_joint_output_type</code></a><code>(model)</code></td><td style="text-align: left"><code>Any</code></td><td style="text-align: left">upper bound on <code>typeof(first(predict_joint(model, ...)))</code></td><td style="text-align: left"><code>Distributions.Sampleable{Distributions.Multivariate,Distributions.Continuous}</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.transform_input_scitype"><code>LearnAPI.transform_input_scitype</code></a><code>(model)</code></td><td style="text-align: left"><code>Union{}</code></td><td style="text-align: left">upper bound on <code>scitype(data)</code> in <code>transform(model, fitted_params, data...)</code>††</td><td style="text-align: left"><code>Table(Continuous)</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.transform_output_scitype"><code>LearnAPI.transform_output_scitype</code></a><code>(model)</code></td><td style="text-align: left"><code>Any</code></td><td style="text-align: left">upper bound on <code>scitype(first(transform(model, ...)))</code></td><td style="text-align: left"><code>Table(Continuous)</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.transform_input_type"><code>LearnAPI.transform_input_type</code></a><code>(model)</code></td><td style="text-align: left"><code>Union{}</code></td><td style="text-align: left">upper bound on <code>typeof(data)</code> in <code>transform(model, fitted_params, data...)</code>††</td><td style="text-align: left"><code>AbstractMatrix{&lt;:Real}}</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.transform_output_type"><code>LearnAPI.transform_output_type</code></a><code>(model)</code></td><td style="text-align: left"><code>Any</code></td><td style="text-align: left">upper bound on <code>typeof(first(transform(model, ...)))</code></td><td style="text-align: left"><code>AbstractMatrix{&lt;:Real}</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.inverse_transform_input_scitype"><code>LearnAPI.inverse_transform_input_scitype</code></a><code>(model)</code></td><td style="text-align: left"><code>Union{}</code></td><td style="text-align: left">upper bound on <code>scitype(data)</code> in <code>inverse_transform(model, fitted_params, data...)</code>††</td><td style="text-align: left"><code>Table(Continuous)</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.inverse_transform_output_scitype"><code>LearnAPI.inverse_transform_output_scitype</code></a><code>(model)</code></td><td style="text-align: left"><code>Any</code></td><td style="text-align: left">upper bound on <code>scitype(first(inverse_transform(model, ...)))</code></td><td style="text-align: left"><code>Table(Continuous)</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.inverse_transform_input_type"><code>LearnAPI.inverse_transform_input_type</code></a><code>(model)</code></td><td style="text-align: left"><code>Union{}</code></td><td style="text-align: left">upper bound on <code>typeof(data)</code> in <code>inverse_transform(model, fitted_params, data...)</code>††</td><td style="text-align: left"><code>AbstractMatrix{&lt;:Real}</code></td></tr><tr><td style="text-align: left"><a href="#LearnAPI.inverse_transform_output_type"><code>LearnAPI.inverse_transform_output_type</code></a><code>(model)</code></td><td style="text-align: left"><code>Any</code></td><td style="text-align: left">upper bound on <code>typeof(first(inverse_transform(model, ...)))</code></td><td style="text-align: left"><code>AbstractMatrix{&lt;:Real}</code></td></tr></table><p>† If the value is <code>0</code>, then the variable in boldface type is not supported and not expected to appear in <code>data</code>. If <code>length(data)</code> is less than the trait value, then <code>data</code> is understood to exclude the variable, but note that <code>fit</code> can have multiple signatures of varying lengths, as in <code>fit(model, verbosity, X, y)</code> and <code>fit(model, verbosity, X, y, w)</code>. A non-zero value is a promise that <code>fit</code> includes a signature of sufficient length to include the variable.</p><p>†† Assuming no <a href="../optional_data_interface/#data_interface">optional data interface</a> is implemented. See docstring for the general case.</p><h2 id="Derived-Traits"><a class="docs-heading-anchor" href="#Derived-Traits">Derived Traits</a><a id="Derived-Traits-1"></a><a class="docs-heading-anchor-permalink" href="#Derived-Traits" title="Permalink"></a></h2><p>The following convenience methods are provided but intended for overloading:</p><table><tr><th style="text-align: left">trait</th><th style="text-align: left">return value</th><th style="text-align: left">example</th></tr><tr><td style="text-align: left"><code>LearnAPI.name(model)</code></td><td style="text-align: left">model type name as string</td><td style="text-align: left">&quot;PCA&quot;</td></tr><tr><td style="text-align: left"><code>LearnAPI.is_model(model)</code></td><td style="text-align: left"><code>true</code> if <code>functions(model)</code> is not empty</td><td style="text-align: left"><code>true</code></td></tr></table><h2 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.functions" href="#LearnAPI.functions"><code>LearnAPI.functions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.functions(model)</code></pre><p>Return a tuple of symbols, such as <code>(:fit, :predict)</code>, corresponding to LearnAPI methods specifically implemented for objects having the same type as <code>model</code>. If non-empty, this also guarantees <code>model</code> is a model, in the LearnAPI sense. See the Reference section of the manual for details.</p><p><strong>New model implementations</strong></p><p>Every LearnAPI method that is not a trait and which is specifically implemented for <code>typeof(model)</code> must be included in the return value of this trait. Specifically, the return value is a tuple of symbols from this list: <code>:fit</code>, <code>:update!</code>, <code>:ingest!</code>, <code>:predict</code>, <code>:predict_joint</code>, <code>:transform</code>, <code>:inverse_transform</code>, <code>:features_importances</code>, <code>:training_labels</code>, <code>:training_losses</code>, <code>:training_scores</code>. To regenerate this list, do <code>LearnAPI.functions()</code>.</p><p>See also <a href="../reference/#LearnAPI.Model"><code>LearnAPI.Model</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/9803f64f143bb9d99ebe5de477bff832aa0ae9cc/src/model_traits.jl#LL57-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.predict_proxy" href="#LearnAPI.predict_proxy"><code>LearnAPI.predict_proxy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.predict_proxy(model)</code></pre><p>Returns an object with abstract type <code>LearnAPI.TargetProxy</code> indicating the kind of proxy for the target returned by the <code>predict</code> method, when called on <code>model</code> and some data. For example, a value of <code>LearnAPI.Distribution()</code> means that <code>predict</code> returns probability distributions, rather than actual values of the target. (<code>LearnAPI.predict</code> also returns a report as second value). A value of <code>LearnAPI.TrueTarget()</code> indicates that ordinary (non-proxy) target values are returned. A value of <code>LearnAPI.None()</code>, implies the output of <code>predict</code> has no declared relationship with any target variable.</p><p><strong>New implementations</strong></p><p>A model with a concept of &quot;target&quot; must overload this trait. The fallback return value is <code>LearnAPI.None()</code>.</p><p>For more on target variables and target proxies, refer to the &quot;Predict and Other Operations&quot; section of the LearnAPI documentation.</p><p>The trait must return a lone instance <code>T()</code> for some subtype <code>T &lt;: LearnAPI.TargetProxy</code>. Here&#39;s a sample implementation for a supervised model where predictions are ordinary values of the target variable:</p><pre><code class="language-julia hljs">@trait MyNewModel predict_proxy = LearnAPI.TrueTarget()</code></pre><p>which is shorthand for</p><pre><code class="language-julia hljs">LearnAPI.predict_proxy(::Type{&lt;:MyNewModelType}) = LearnAPI.TrueTarget()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/9803f64f143bb9d99ebe5de477bff832aa0ae9cc/src/model_traits.jl#LL78-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.predict_joint_proxy" href="#LearnAPI.predict_joint_proxy"><code>LearnAPI.predict_joint_proxy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.predict_joint_proxy(model)</code></pre><p>Returns an object with abstract type <code>LearnAPI.TargetProxy</code> indicating the kind of proxy for the target returned by the <code>predict_joint</code> method, when called on <code>model</code> and some data. For example, a value of <code>LearnAPI.Distribution()</code> means that <code>predict_joint</code> returns a probability distribution, rather than, say a merely sampleable object.</p><p><strong>New implementations</strong></p><p>Any model implementing <code>LearnAPI.predict_joint</code> must overload this trait.</p><p>For more on target variables and target proxies, refer to the LearnAPI documentation.</p><p>The possible return values for this trait are: <code>LearnAPI.JointSampleable()</code>, <code>LearnAPI.JointDistribution()</code> and <code>LearnAPI.JointLogDistribution()</code>.</p><p>Here&#39;s a sample implementation:</p><pre><code class="language-julia hljs">@trait MyNewModel predict_joint_proxy = LearnAPI.JointDistribution()</code></pre><p>which is shorthand for</p><pre><code class="language-julia hljs">LearnAPI.predict_joint_proxy(::Type{&lt;:MyNewModelType}) = LearnAPI.JointDistribution()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/9803f64f143bb9d99ebe5de477bff832aa0ae9cc/src/model_traits.jl#LL115-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.position_of_target" href="#LearnAPI.position_of_target"><code>LearnAPI.position_of_target</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.position_of_target(model)</code></pre><p>Return the expected position of the target variable within <code>data</code> in calls of the form <a href="../fit_update_and_ingest/#LearnAPI.fit"><code>LearnAPI.fit</code></a><code>(model, verbosity, data...)</code>.</p><p>If this number is <code>0</code>, then no target is expected. If this number exceeds <code>length(data)</code>, then <code>data</code> is understood to exclude the target variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/9803f64f143bb9d99ebe5de477bff832aa0ae9cc/src/model_traits.jl#LL147-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.position_of_weights" href="#LearnAPI.position_of_weights"><code>LearnAPI.position_of_weights</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.position_of_weights(model)</code></pre><p>Return the expected position of per-observation weights within <code>data</code> in calls of the form <a href="../fit_update_and_ingest/#LearnAPI.fit"><code>LearnAPI.fit</code></a><code>(model, verbosity, data...)</code>.</p><p>If this number is <code>0</code>, then no weights are expected. If this number exceeds <code>length(data)</code>, then <code>data</code> is understood to exclude weights, which are assumed to be uniform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/9803f64f143bb9d99ebe5de477bff832aa0ae9cc/src/model_traits.jl#LL159-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.descriptors" href="#LearnAPI.descriptors"><code>LearnAPI.descriptors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.descriptors(model)</code></pre><p>Lists one or more suggestive model descriptors from this list: <code>:regression</code>, <code>:classification</code>, <code>:clustering</code>, <code>:gradient_descent</code>, <code>:iterative_model</code>, <code>:incremental_model</code>, <code>:dimension_reduction</code>, <code>:transformer</code>, <code>:static_transformer</code>, <code>:missing_value_imputer</code>, <code>:ensemble_model</code>, <code>:wrapper</code>, <code>:time_series_forecaster</code>, <code>:time_series_classifier</code>, <code>:survival_analysis</code>, <code>:distribution_fitter</code>, <code>:Bayesian_model</code>, <code>:outlier_detection</code>, <code>:collaborative_filtering</code>, <code>:text_analysis</code>, <code>:audio_analysis</code>, <code>:natural_language_processing</code>, <code>:image_processing</code> (do <code>LearnAPI.descriptors()</code> to reproduce).</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The value of this trait guarantees no particular behavior. The trait is intended for informal classification purposes only.</p></div></div><p><strong>New model implementations</strong></p><p>This trait should return a tuple of symbols, as in <code>(:classifier, :probabilistic)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/9803f64f143bb9d99ebe5de477bff832aa0ae9cc/src/model_traits.jl#LL200-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.is_pure_julia" href="#LearnAPI.is_pure_julia"><code>LearnAPI.is_pure_julia</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.is_pure_julia(model)</code></pre><p>Returns <code>true</code> if training <code>model</code> requires evaluation of pure Julia code only.</p><p><strong>New model implementations</strong></p><p>The fallback is <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/9803f64f143bb9d99ebe5de477bff832aa0ae9cc/src/model_traits.jl#LL217-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.pkg_name" href="#LearnAPI.pkg_name"><code>LearnAPI.pkg_name</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.pkg_name(model)</code></pre><p>Return the name of the package module which supplies the core training algorithm for <code>model</code>.  This is not necessarily the package providing the LearnAPI interface.</p><p>Returns <code>&quot;unknown&quot;</code> if the model implementation has failed to overload the trait. </p><p><strong>New model implementations</strong></p><p>Must return a string, as in <code>&quot;DecisionTree&quot;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/9803f64f143bb9d99ebe5de477bff832aa0ae9cc/src/model_traits.jl#LL229-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.pkg_license" href="#LearnAPI.pkg_license"><code>LearnAPI.pkg_license</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.pkg_license(model)</code></pre><p>Return the name of the software license, such as <code>&quot;MIT&quot;</code>, applying to the package where the core algorithm for <code>model</code> is implemented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/9803f64f143bb9d99ebe5de477bff832aa0ae9cc/src/model_traits.jl#LL245-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.doc_url" href="#LearnAPI.doc_url"><code>LearnAPI.doc_url</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.doc_url(model)</code></pre><p>Return a url where the core algorithm for <code>model</code> is documented.</p><p>Returns <code>&quot;unknown&quot;</code> if the model implementation has failed to overload the trait. </p><p><strong>New model implementations</strong></p><p>Must return a string, such as <code>&quot;https://en.wikipedia.org/wiki/Decision_tree_learning&quot;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/9803f64f143bb9d99ebe5de477bff832aa0ae9cc/src/model_traits.jl#LL254-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.load_path" href="#LearnAPI.load_path"><code>LearnAPI.load_path</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.load_path(model)</code></pre><p>Return a string indicating where the <code>struct</code> for <code>typeof(model)</code> can be found, beginning with the name of the package module defining it. For example, a return value of <code>&quot;FastTrees.LearnAPI.DecisionTreeClassifier&quot;</code> means the following julia code will return the model type:</p><pre><code class="language-julia hljs">import FastTrees
FastTrees.LearnAPI.DecisionTreeClassifier</code></pre><p>Returns <code>&quot;unknown&quot;</code> if the model implementation has failed to overload the trait. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/9803f64f143bb9d99ebe5de477bff832aa0ae9cc/src/model_traits.jl#LL268-L284">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.is_wrapper" href="#LearnAPI.is_wrapper"><code>LearnAPI.is_wrapper</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.is_wrapper(model)</code></pre><p>Returns <code>true</code> if one or more properties (fields) of <code>model</code> may themselves be models, and <code>false</code> otherwise.</p><p><strong>New model implementations</strong></p><p>This trait must be overloaded if one or more properties (fields) of <code>model</code> may take model values. Fallback return value is <code>false</code>.</p><p>The value of the trait must depend only on the type of <code>model</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/9803f64f143bb9d99ebe5de477bff832aa0ae9cc/src/model_traits.jl#LL288-L302">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.fit_keywords" href="#LearnAPI.fit_keywords"><code>LearnAPI.fit_keywords</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.fit_keywords(model)</code></pre><p>Return a list of keywords that can be provided to <code>fit</code> that correspond to metadata; <code>metadata</code> is for extra information pertaining to the data that is never iterated or subsampled, eg., weights for target classes, or feature names (if these are not embedded in the representation of <code>data</code>). Another example would be feature groupings in the group lasso algorithm. </p><p><strong>New model implementations</strong></p><p>If <code>LearnAPI.fit(model, ...)</code> supports keyword arguments, then this trait must be overloaded, and otherwise not. Fallback returns <code>()</code>.</p><p>Here&#39;s a sample implementation for a classifier that implements a <code>LearnAPI.fit</code> method with signature <code>fit(model::MyClassifier, verbosity, X, y; class_weights=nothing)</code>:</p><pre><code class="nohighlight hljs">LearnAPI.fit_keywords(::Type{&lt;:MyClassifier}) = (:class_weights,)</code></pre><p>or the shorthand</p><pre><code class="nohighlight hljs">@trait MyClassifier fit_keywords=(:class_weights,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/9803f64f143bb9d99ebe5de477bff832aa0ae9cc/src/model_traits.jl#LL334-L359">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.human_name" href="#LearnAPI.human_name"><code>LearnAPI.human_name</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.human_name(model)</code></pre><p>A human-readable string representation of <code>typeof(model)</code>. Primarily intended for auto-generation of documentation.</p><p><strong>New model implementations</strong></p><p>Optional. A fallback takes the type name, inserts spaces and removes capitalization. For example, <code>KNNRegressor</code> becomes <code>&quot;knn regressor&quot;</code>. Better would be to overload the trait to return <code>&quot;K-nearest neighbors regressor&quot;</code>. Ideally, this is a &quot;concrete&quot; noun like <code>&quot;ridge regressor&quot;</code> rather than an &quot;abstract&quot; noun like <code>&quot;ridge regression&quot;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/9803f64f143bb9d99ebe5de477bff832aa0ae9cc/src/model_traits.jl#LL305-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.iteration_parameter" href="#LearnAPI.iteration_parameter"><code>LearnAPI.iteration_parameter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.iteration_parameter(model)</code></pre><p>The name of the iteration parameter of <code>model</code>, or <code>nothing</code> if the model is not iterative.</p><p><strong>New model implementations</strong></p><p>Implement if model is iterative. Returns a symbol or <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/9803f64f143bb9d99ebe5de477bff832aa0ae9cc/src/model_traits.jl#LL321-L331">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.fit_scitype" href="#LearnAPI.fit_scitype"><code>LearnAPI.fit_scitype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.fit_scitype(model)</code></pre><p>Return an upper bound on the scitype of data guaranteeing it to work when training <code>model</code>.</p><p>Specifically, if the return value is <code>S</code> and <code>ScientificTypes.scitype(data) &lt;: S</code>, then the following low-level calls are allowed (assuming <code>metadata</code> is also valid and <code>verbosity</code> is an integer):</p><pre><code class="language-julia hljs"># apply data front-end:
data2, metadata2 = LearnAPI.reformat(model, LearnAPI.fit, data...; metadata...)

# train:
LearnAPI.fit(model, verbosity, data2...; metadata2...)</code></pre><p>See also <a href="#LearnAPI.fit_type"><code>LearnAPI.fit_type</code></a>, <a href="#LearnAPI.fit_observation_scitype"><code>LearnAPI.fit_observation_scitype</code></a>, <a href="#LearnAPI.fit_observation_type"><code>LearnAPI.fit_observation_type</code></a>.</p><p><strong>New model implementations</strong></p><p>Optional. The fallback return value is <code>Union{}</code>.  No more than one of the following should be overloaded for a model type: <code>LearnAPI.fit_scitype</code>, <code>LearnAPI.fit_type</code>, <code>LearnAPI.fit_observation_scitype</code>, <code>LearnAPI.fit_observation_type</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/9803f64f143bb9d99ebe5de477bff832aa0ae9cc/src/model_traits.jl#LL362-L387">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.fit_type" href="#LearnAPI.fit_type"><code>LearnAPI.fit_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.fit_type(model)</code></pre><p>Return an upper bound on the type of data guaranteeing it to work when training <code>model</code>.</p><p>Specifically, if the return value is <code>T</code> and <code>typeof(data) &lt;: T</code>, then the following low-level calls are allowed (assuming <code>metadata</code> is also valid and <code>verbosity</code> is an integer):</p><pre><code class="language-julia hljs"># apply data front-end:
data2, metadata2 = LearnAPI.reformat(model, LearnAPI.fit, data...; metadata...)

# train:
LearnAPI.fit(model, verbosity, data2...; metadata2...)</code></pre><p>See also <a href="#LearnAPI.fit_scitype"><code>LearnAPI.fit_scitype</code></a>, <a href="#LearnAPI.fit_observation_type"><code>LearnAPI.fit_observation_type</code></a>. <a href="#LearnAPI.fit_observation_scitype"><code>LearnAPI.fit_observation_scitype</code></a></p><p><strong>New model implementations</strong></p><p>Optional. The fallback return value is <code>Union{}</code>. No more than one of the following should be overloaded for a model type: <code>LearnAPI.fit_scitype</code>, <code>LearnAPI.fit_type</code>, <code>LearnAPI.fit_observation_scitype</code>, <code>LearnAPI.fit_observation_type</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/9803f64f143bb9d99ebe5de477bff832aa0ae9cc/src/model_traits.jl#LL423-L447">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.fit_observation_scitype" href="#LearnAPI.fit_observation_scitype"><code>LearnAPI.fit_observation_scitype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.fit_observation_scitype(model)</code></pre><p>Return an upper bound on the scitype of observations guaranteed to work when training <code>model</code> (independent of the type/scitype of the data container itself).</p><p>Specifically, denoting the type returned above by <code>S</code>, suppose a user supplies training data, <code>data</code> - typically a tuple, such as <code>(X, y)</code> - and valid metadata, <code>metadata</code>, and one computes</p><pre><code class="nohighlight hljs">data2, metadata2 = LearnAPI.reformat(model, LearnAPI.fit, data...; metadata...)</code></pre><p>Then, assuming</p><pre><code class="nohighlight hljs">ScientificTypes.scitype(LearnAPI.getobs(model, LearnAPI.fit, data2, i)) &lt;: S</code></pre><p>for any valid index <code>i</code>, the following is guaranteed to work:</p><pre><code class="language-julia hljs">LearnAPI.fit(model, verbosity, data2...; metadata2...)</code></pre><p>See also See also <a href="#LearnAPI.fit_type"><code>LearnAPI.fit_type</code></a>, <a href="#LearnAPI.fit_scitype"><code>LearnAPI.fit_scitype</code></a>, <a href="#LearnAPI.fit_observation_type"><code>LearnAPI.fit_observation_type</code></a>.</p><p><strong>New model implementations</strong></p><p>Optional. The fallback return value is <code>Union{}</code>. No more than one of the following should be overloaded for a model type: <code>LearnAPI.fit_scitype</code>, <code>LearnAPI.fit_type</code>, <code>LearnAPI.fit_observation_scitype</code>, <code>LearnAPI.fit_observation_type</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/9803f64f143bb9d99ebe5de477bff832aa0ae9cc/src/model_traits.jl#LL390-L420">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.fit_observation_type" href="#LearnAPI.fit_observation_type"><code>LearnAPI.fit_observation_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.fit_observation_type(model)</code></pre><p>Return an upper bound on the type of observations guaranteed to work when training <code>model</code> (independent of the type/scitype of the data container itself).</p><p>Specifically, denoting the type returned above by <code>T</code>, suppose a user supplies training data, <code>data</code> - typically a tuple, such as <code>(X, y)</code> - and valid metadata, <code>metadata</code>, and one computes</p><pre><code class="nohighlight hljs">data2, metadata2 = LearnAPI.reformat(model, LearnAPI.fit, data...; metadata...)</code></pre><p>Then, assuming</p><pre><code class="nohighlight hljs">typeof(LearnAPI.getobs(model, LearnAPI.fit, data2, i)) &lt;: T</code></pre><p>for any valid index <code>i</code>, the following is guaranteed to work:</p><pre><code class="language-julia hljs">LearnAPI.fit(model, verbosity, data2...; metadata2...)</code></pre><p>See also See also <a href="#LearnAPI.fit_type"><code>LearnAPI.fit_type</code></a>, <a href="#LearnAPI.fit_scitype"><code>LearnAPI.fit_scitype</code></a>, <a href="#LearnAPI.fit_observation_scitype"><code>LearnAPI.fit_observation_scitype</code></a>.</p><p><strong>New model implementations</strong></p><p>Optional. The fallback return value is <code>Union{}</code>. No more than one of the following should be overloaded for a model type: <code>LearnAPI.fit_scitype</code>, <code>LearnAPI.fit_type</code>, <code>LearnAPI.fit_observation_scitype</code>, <code>LearnAPI.fit_observation_type</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/9803f64f143bb9d99ebe5de477bff832aa0ae9cc/src/model_traits.jl#LL450-L480">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.predict_input_scitype" href="#LearnAPI.predict_input_scitype"><code>LearnAPI.predict_input_scitype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> LearnAPI.predict_input_scitype(model)</code></pre><p>Return an upper bound on the scitype of input data guaranteed to work with the <code>predict</code>  operation.</p><p>Specifically, if <code>S</code> is the value returned and <code>ScientificTypes.scitype(data) &lt;: S</code>,  then the following low-level calls are allowed</p><pre><code class="nohighlight hljs"> data2 = LearnAPI.reformat(model, LearnAPI.predict, data...)
 LearnAPI.predict(model, fitted_params, data2...)</code></pre><p>Here <code>fitted_params</code> are the learned parameters returned by an appropriate call to  <code>LearnAPI.fit</code>.</p><p>See also <a href="#LearnAPI.predict_input_type"><code>LearnAPI.predict_input_type</code></a>.</p><p><strong>New model implementations</strong></p><p>Implementation is optional. The fallback return value is <code>Union{}</code>. Should not be  overloaded if <code>LearnAPI.predict_input_type</code> is overloaded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/9803f64f143bb9d99ebe5de477bff832aa0ae9cc/src/model_traits.jl#LL577-L599">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.predict_output_scitype" href="#LearnAPI.predict_output_scitype"><code>LearnAPI.predict_output_scitype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.predict_output_scitype(model)</code></pre><p>Return an upper bound on the scitype of the output of the <code>predict</code> operation.</p><p>Specifically, if <code>S</code> is the value returned, and if</p><pre><code class="nohighlight hljs">output, report = LearnAPI.predict(model, fitted_params, data...)</code></pre><p>for suitable <code>fitted_params</code> and <code>data</code>, then</p><pre><code class="nohighlight hljs">ScientificTypes.scitype(output) &lt;: S</code></pre><p>See also <a href="#LearnAPI.predict_input_scitype"><code>LearnAPI.predict_input_scitype</code></a>.</p><p><strong>New model implementations</strong></p><p>Implementation is optional. The fallback return value is <code>Any</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/9803f64f143bb9d99ebe5de477bff832aa0ae9cc/src/model_traits.jl#LL580-L599">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.predict_input_type" href="#LearnAPI.predict_input_type"><code>LearnAPI.predict_input_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.predict_input_type(model)</code></pre><p>Return an upper bound on the type of input data guaranteed to work with the <code>predict</code> operation.</p><p>Specifically, if <code>T</code> is the value returned and <code>typeof(data) &lt;: S</code>, then the following low-level calls are allowed</p><pre><code class="nohighlight hljs">data2 = LearnAPI.reformat(model, LearnAPI.predict, data...)
LearnAPI.predict(model, fitted_params, data2...)</code></pre><p>Here <code>fitted_params</code> are the learned parameters returned by an appropriate call to <code>LearnAPI.fit</code>.</p><p>See also <a href="#LearnAPI.predict_input_scitype"><code>LearnAPI.predict_input_scitype</code></a>.</p><p><strong>New model implementations</strong></p><p>Implementation is optional. The fallback return value is <code>Union{}</code>. Should not be overloaded if <code>LearnAPI.predict_input_scitype</code> is overloaded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/9803f64f143bb9d99ebe5de477bff832aa0ae9cc/src/model_traits.jl#LL583-L605">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.predict_output_type" href="#LearnAPI.predict_output_type"><code>LearnAPI.predict_output_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.predict_output_type(model)</code></pre><p>Return an upper bound on the type of the output of the <code>predict</code> operation.</p><p>Specifically, if <code>T</code> is the value returned, and if</p><pre><code class="nohighlight hljs">output, report = LearnAPI.predict(model, fitted_params, data...)</code></pre><p>for suitable <code>fitted_params</code> and <code>data</code>, then</p><pre><code class="nohighlight hljs">typeof(output) &lt;: T</code></pre><p>See also <a href="#LearnAPI.predict_input_type"><code>LearnAPI.predict_input_type</code></a>.</p><p><strong>New model implementations</strong></p><p>Implementation is optional. The fallback return value is <code>Any</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/9803f64f143bb9d99ebe5de477bff832aa0ae9cc/src/model_traits.jl#LL586-L605">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.predict_joint_input_scitype" href="#LearnAPI.predict_joint_input_scitype"><code>LearnAPI.predict_joint_input_scitype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> LearnAPI.predict_joint_input_scitype(model)</code></pre><p>Return an upper bound on the scitype of input data guaranteed to work with the <code>predict_joint</code>  operation.</p><p>Specifically, if <code>S</code> is the value returned and <code>ScientificTypes.scitype(data) &lt;: S</code>,  then the following low-level calls are allowed</p><pre><code class="nohighlight hljs"> data2 = LearnAPI.reformat(model, LearnAPI.predict_joint, data...)
 LearnAPI.predict_joint(model, fitted_params, data2...)</code></pre><p>Here <code>fitted_params</code> are the learned parameters returned by an appropriate call to  <code>LearnAPI.fit</code>.</p><p>See also <a href="#LearnAPI.predict_joint_input_type"><code>LearnAPI.predict_joint_input_type</code></a>.</p><p><strong>New model implementations</strong></p><p>Implementation is optional. The fallback return value is <code>Union{}</code>. Should not be  overloaded if <code>LearnAPI.predict_joint_input_type</code> is overloaded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/9803f64f143bb9d99ebe5de477bff832aa0ae9cc/src/model_traits.jl#LL589-L611">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.predict_joint_output_scitype" href="#LearnAPI.predict_joint_output_scitype"><code>LearnAPI.predict_joint_output_scitype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.predict_joint_output_scitype(model)</code></pre><p>Return an upper bound on the scitype of the output of the <code>predict_joint</code> operation.</p><p>Specifically, if <code>S</code> is the value returned, and if</p><pre><code class="nohighlight hljs">output, report = LearnAPI.predict_joint(model, fitted_params, data...)</code></pre><p>for suitable <code>fitted_params</code> and <code>data</code>, then</p><pre><code class="nohighlight hljs">ScientificTypes.scitype(output) &lt;: S</code></pre><p>See also <a href="#LearnAPI.predict_joint_input_scitype"><code>LearnAPI.predict_joint_input_scitype</code></a>.</p><p><strong>New model implementations</strong></p><p>Implementation is optional. The fallback return value is <code>Any</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/9803f64f143bb9d99ebe5de477bff832aa0ae9cc/src/model_traits.jl#LL592-L611">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.predict_joint_input_type" href="#LearnAPI.predict_joint_input_type"><code>LearnAPI.predict_joint_input_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.predict_joint_input_type(model)</code></pre><p>Return an upper bound on the type of input data guaranteed to work with the <code>predict_joint</code> operation.</p><p>Specifically, if <code>T</code> is the value returned and <code>typeof(data) &lt;: S</code>, then the following low-level calls are allowed</p><pre><code class="nohighlight hljs">data2 = LearnAPI.reformat(model, LearnAPI.predict_joint, data...)
LearnAPI.predict_joint(model, fitted_params, data2...)</code></pre><p>Here <code>fitted_params</code> are the learned parameters returned by an appropriate call to <code>LearnAPI.fit</code>.</p><p>See also <a href="#LearnAPI.predict_joint_input_scitype"><code>LearnAPI.predict_joint_input_scitype</code></a>.</p><p><strong>New model implementations</strong></p><p>Implementation is optional. The fallback return value is <code>Union{}</code>. Should not be overloaded if <code>LearnAPI.predict_joint_input_scitype</code> is overloaded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/9803f64f143bb9d99ebe5de477bff832aa0ae9cc/src/model_traits.jl#LL595-L617">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.predict_joint_output_type" href="#LearnAPI.predict_joint_output_type"><code>LearnAPI.predict_joint_output_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.predict_joint_output_type(model)</code></pre><p>Return an upper bound on the type of the output of the <code>predict_joint</code> operation.</p><p>Specifically, if <code>T</code> is the value returned, and if</p><pre><code class="nohighlight hljs">output, report = LearnAPI.predict_joint(model, fitted_params, data...)</code></pre><p>for suitable <code>fitted_params</code> and <code>data</code>, then</p><pre><code class="nohighlight hljs">typeof(output) &lt;: T</code></pre><p>See also <a href="#LearnAPI.predict_joint_input_type"><code>LearnAPI.predict_joint_input_type</code></a>.</p><p><strong>New model implementations</strong></p><p>Implementation is optional. The fallback return value is <code>Any</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/9803f64f143bb9d99ebe5de477bff832aa0ae9cc/src/model_traits.jl#LL598-L617">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.transform_input_scitype" href="#LearnAPI.transform_input_scitype"><code>LearnAPI.transform_input_scitype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> LearnAPI.transform_input_scitype(model)</code></pre><p>Return an upper bound on the scitype of input data guaranteed to work with the <code>transform</code>  operation.</p><p>Specifically, if <code>S</code> is the value returned and <code>ScientificTypes.scitype(data) &lt;: S</code>,  then the following low-level calls are allowed</p><pre><code class="nohighlight hljs"> data2 = LearnAPI.reformat(model, LearnAPI.transform, data...)
 LearnAPI.transform(model, fitted_params, data2...)</code></pre><p>Here <code>fitted_params</code> are the learned parameters returned by an appropriate call to  <code>LearnAPI.fit</code>.</p><p>See also <a href="#LearnAPI.transform_input_type"><code>LearnAPI.transform_input_type</code></a>.</p><p><strong>New model implementations</strong></p><p>Implementation is optional. The fallback return value is <code>Union{}</code>. Should not be  overloaded if <code>LearnAPI.transform_input_type</code> is overloaded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/9803f64f143bb9d99ebe5de477bff832aa0ae9cc/src/model_traits.jl#LL601-L623">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.transform_output_scitype" href="#LearnAPI.transform_output_scitype"><code>LearnAPI.transform_output_scitype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.transform_output_scitype(model)</code></pre><p>Return an upper bound on the scitype of the output of the <code>transform</code> operation.</p><p>Specifically, if <code>S</code> is the value returned, and if</p><pre><code class="nohighlight hljs">output, report = LearnAPI.transform(model, fitted_params, data...)</code></pre><p>for suitable <code>fitted_params</code> and <code>data</code>, then</p><pre><code class="nohighlight hljs">ScientificTypes.scitype(output) &lt;: S</code></pre><p>See also <a href="#LearnAPI.transform_input_scitype"><code>LearnAPI.transform_input_scitype</code></a>.</p><p><strong>New model implementations</strong></p><p>Implementation is optional. The fallback return value is <code>Any</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/9803f64f143bb9d99ebe5de477bff832aa0ae9cc/src/model_traits.jl#LL604-L623">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.transform_input_type" href="#LearnAPI.transform_input_type"><code>LearnAPI.transform_input_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.transform_input_type(model)</code></pre><p>Return an upper bound on the type of input data guaranteed to work with the <code>transform</code> operation.</p><p>Specifically, if <code>T</code> is the value returned and <code>typeof(data) &lt;: S</code>, then the following low-level calls are allowed</p><pre><code class="nohighlight hljs">data2 = LearnAPI.reformat(model, LearnAPI.transform, data...)
LearnAPI.transform(model, fitted_params, data2...)</code></pre><p>Here <code>fitted_params</code> are the learned parameters returned by an appropriate call to <code>LearnAPI.fit</code>.</p><p>See also <a href="#LearnAPI.transform_input_scitype"><code>LearnAPI.transform_input_scitype</code></a>.</p><p><strong>New model implementations</strong></p><p>Implementation is optional. The fallback return value is <code>Union{}</code>. Should not be overloaded if <code>LearnAPI.transform_input_scitype</code> is overloaded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/9803f64f143bb9d99ebe5de477bff832aa0ae9cc/src/model_traits.jl#LL607-L629">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.transform_output_type" href="#LearnAPI.transform_output_type"><code>LearnAPI.transform_output_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.transform_output_type(model)</code></pre><p>Return an upper bound on the type of the output of the <code>transform</code> operation.</p><p>Specifically, if <code>T</code> is the value returned, and if</p><pre><code class="nohighlight hljs">output, report = LearnAPI.transform(model, fitted_params, data...)</code></pre><p>for suitable <code>fitted_params</code> and <code>data</code>, then</p><pre><code class="nohighlight hljs">typeof(output) &lt;: T</code></pre><p>See also <a href="#LearnAPI.transform_input_type"><code>LearnAPI.transform_input_type</code></a>.</p><p><strong>New model implementations</strong></p><p>Implementation is optional. The fallback return value is <code>Any</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/9803f64f143bb9d99ebe5de477bff832aa0ae9cc/src/model_traits.jl#LL610-L629">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.inverse_transform_input_scitype" href="#LearnAPI.inverse_transform_input_scitype"><code>LearnAPI.inverse_transform_input_scitype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> LearnAPI.inverse_transform_input_scitype(model)</code></pre><p>Return an upper bound on the scitype of input data guaranteed to work with the <code>inverse_transform</code>  operation.</p><p>Specifically, if <code>S</code> is the value returned and <code>ScientificTypes.scitype(data) &lt;: S</code>,  then the following low-level calls are allowed</p><pre><code class="nohighlight hljs"> data2 = LearnAPI.reformat(model, LearnAPI.inverse_transform, data...)
 LearnAPI.inverse_transform(model, fitted_params, data2...)</code></pre><p>Here <code>fitted_params</code> are the learned parameters returned by an appropriate call to  <code>LearnAPI.fit</code>.</p><p>See also <a href="#LearnAPI.inverse_transform_input_type"><code>LearnAPI.inverse_transform_input_type</code></a>.</p><p><strong>New model implementations</strong></p><p>Implementation is optional. The fallback return value is <code>Union{}</code>. Should not be  overloaded if <code>LearnAPI.inverse_transform_input_type</code> is overloaded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/9803f64f143bb9d99ebe5de477bff832aa0ae9cc/src/model_traits.jl#LL613-L635">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.inverse_transform_output_scitype" href="#LearnAPI.inverse_transform_output_scitype"><code>LearnAPI.inverse_transform_output_scitype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.inverse_transform_output_scitype(model)</code></pre><p>Return an upper bound on the scitype of the output of the <code>inverse_transform</code> operation.</p><p>Specifically, if <code>S</code> is the value returned, and if</p><pre><code class="nohighlight hljs">output, report = LearnAPI.inverse_transform(model, fitted_params, data...)</code></pre><p>for suitable <code>fitted_params</code> and <code>data</code>, then</p><pre><code class="nohighlight hljs">ScientificTypes.scitype(output) &lt;: S</code></pre><p>See also <a href="#LearnAPI.inverse_transform_input_scitype"><code>LearnAPI.inverse_transform_input_scitype</code></a>.</p><p><strong>New model implementations</strong></p><p>Implementation is optional. The fallback return value is <code>Any</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/9803f64f143bb9d99ebe5de477bff832aa0ae9cc/src/model_traits.jl#LL616-L635">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.inverse_transform_input_type" href="#LearnAPI.inverse_transform_input_type"><code>LearnAPI.inverse_transform_input_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.inverse_transform_input_type(model)</code></pre><p>Return an upper bound on the type of input data guaranteed to work with the <code>inverse_transform</code> operation.</p><p>Specifically, if <code>T</code> is the value returned and <code>typeof(data) &lt;: S</code>, then the following low-level calls are allowed</p><pre><code class="nohighlight hljs">data2 = LearnAPI.reformat(model, LearnAPI.inverse_transform, data...)
LearnAPI.inverse_transform(model, fitted_params, data2...)</code></pre><p>Here <code>fitted_params</code> are the learned parameters returned by an appropriate call to <code>LearnAPI.fit</code>.</p><p>See also <a href="#LearnAPI.inverse_transform_input_scitype"><code>LearnAPI.inverse_transform_input_scitype</code></a>.</p><p><strong>New model implementations</strong></p><p>Implementation is optional. The fallback return value is <code>Union{}</code>. Should not be overloaded if <code>LearnAPI.inverse_transform_input_scitype</code> is overloaded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/9803f64f143bb9d99ebe5de477bff832aa0ae9cc/src/model_traits.jl#LL619-L641">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LearnAPI.inverse_transform_output_type" href="#LearnAPI.inverse_transform_output_type"><code>LearnAPI.inverse_transform_output_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LearnAPI.inverse_transform_output_type(model)</code></pre><p>Return an upper bound on the type of the output of the <code>inverse_transform</code> operation.</p><p>Specifically, if <code>T</code> is the value returned, and if</p><pre><code class="nohighlight hljs">output, report = LearnAPI.inverse_transform(model, fitted_params, data...)</code></pre><p>for suitable <code>fitted_params</code> and <code>data</code>, then</p><pre><code class="nohighlight hljs">typeof(output) &lt;: T</code></pre><p>See also <a href="#LearnAPI.inverse_transform_input_type"><code>LearnAPI.inverse_transform_input_type</code></a>.</p><p><strong>New model implementations</strong></p><p>Implementation is optional. The fallback return value is <code>Any</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAI/LearnAPI.jl/blob/9803f64f143bb9d99ebe5de477bff832aa0ae9cc/src/model_traits.jl#LL622-L641">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../optional_data_interface/">« Optional Data Interface</a><a class="docs-footer-nextpage" href="../common_implementation_patterns/">Common Implementation Patterns »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Monday 16 January 2023 03:48">Monday 16 January 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
